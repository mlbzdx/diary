回顾http请求？

普通模式？三次握手！四次挥手？

长连接模式？

两者相比，浪费响应时间

同一个连接中请求多次

创建连接后服务端不马上断开连接

请求头添加：`Connection:keep-alive`

断开连接可能由服务端发出，也有可能由客户端发出

http建立再 TCP/IP上的

net模块能干啥，数据通信

- 进程之间的通信 IPC
- 网络通信 TCP/IP

### 创建客户端：

第一步是要引入 `net`模块，然乎调用其相关方法创建客户端和操作客户端。

```javascript
const net = require('net');
```

方法：`net.createConnection()`

作用：`net.createConnection()`方法用于创建一个TCP连接到指定的服务器。

可接受参数：

- 配置对象

  它接受一个包含连接配置的对象作为参数，配置对象中可以包含以下属性：

  1. port：指定服务器的端口号。
  2. host：指定服务器的主机地址。如果省略，默认为'localhost'。
  3. `localAddress`：可选，指定客户端的本地地址。
  4. `localPort`：可选，指定客户端的本地端口。
  5. family：可选，指定IP协议版本，可以是4或6。
  6. hints：可选，指定DNS解析的选项。
  7. lookup：可选，自定义DNS解析函数。

  创建连接后，客户端可以通过返回的socket对象进行数据的读写操作，并监听连接、数据、错误等事件。可以通过该方法创建客户端与服务器进行通信。

- 回调函数

  `net.createConnection()`方法除了上述提到的参数外，还可以接受一个可选的回调函数作为最后一个参数。这个回调函数会在连接建立成功后被调用，可以用于处理连接成功后的逻辑。示例代码如下：

  ```javascript
  const client = net.createConnection({ port: 3000, host: 'localhost' }, () => {
    console.log('Connected to server');
  });
  ```

  在上面的示例中，箭头函数() => { console.log('Connected to server'); } 就是一个可选的回调函数，用于在连接成功时输出一条日志。使用回调函数可以方便地处理连接成功后的逻辑操作。

返回值：

`net.createConnection()`方法会返回一个net.Socket对象，表示与服务器建立的TCP连接。通过这个Socket对象，可以进行数据的读写操作，监听连接、数据、错误等事件。可以通过Socket对象发送数据到服务器，接收服务器发送的数据，以及关闭连接等操作。

在创建连接成功后，可以通过返回的Socket对象来操作与服务器的通信。例如，可以使用write()方法向服务器发送数据，使用on()方法监听data事件来接收服务器发送的数据。通过Socket对象，可以实现客户端与服务器之间的双向通信。

> 知识补充：socket
>
> 在Node.js中，socket是一个抽象概念，代表了网络通信中的一个端点。在TCP通信中，一个socket通常由一个IP地址和一个端口号组成，用于标识网络中的一个通信端点。在Node.js中，socket通常指代一个TCP连接的实例，通过它可以进行数据的读写操作，监听连接、数据、错误等事件。
>
> 在网络编程中，socket是实现网络通信的基本组件，它允许不同计算机之间的进程进行数据交换。通过socket，可以建立客户端与服务器之间的通信连接，进行数据的传输和交换。在Node.js中，通过net模块可以创建和操作socket，实现网络通信功能。

### 读取信息：

Socket对象的on()方法用于注册事件处理程序，监听特定事件的发生。当指定的事件发生时，注册的事件处理程序会被调用。Socket对象可以监听多种事件，如连接建立、数据接收、错误发生等。语法如下：

```javascript
socket.on(eventName, callback)
```

其中，`eventName`是要监听的事件名称，如'data'、'connect'、'error'等；callback是事件发生时要执行的回调函数。当事件发生时，回调函数会被调用，并且可以传入一些参数，如数据、错误信息等，具体取决于事件类型。

> 在Node.js中，不同的核心模块和第三方模块可能会触发不同的事件，这些事件名称可能会有所不同。以下是一些常见的事件名称，这些事件可以在Node.js中的各种模块中被触发：
>
> 1. `'data'`：用于表示数据可用的事件，通常在流（Stream）对象中使用。
> 2. `'end'`：表示数据传输结束的事件。
> 3. `'error'`：表示发生错误的事件，通常在各种操作中使用。
> 4. `'close'`：表示关闭事件，通常在网络连接关闭、文件关闭等情况下使用。
> 5. `'connection'`：表示连接建立的事件，通常在网络编程中使用。
> 6. `'listening'`：表示开始监听的事件，通常在服务器启动时使用。
> 7. `'request'`：表示收到HTTP请求的事件，通常在HTTP服务器中使用。
> 8. `'response'`：表示发送HTTP响应的事件，通常在HTTP客户端中使用。
> 9. `'timeout'`：表示超时事件，通常在网络编程中使用。
>
> 以上是一些常见的事件名称，不同模块和场景下可能会有更多不同的事件名称。在编写Node.js应用程序时，根据实际需求和使用的模块，可以查看相应模块的文档以了解该模块可能触发的事件名称。

例如，监听'data'事件并输出接收到的数据：

```javascript
socket.on('data', (data) => {
  console.log('Received data: ' + data);
});
```

通过使用Socket对象的on()方法，可以方便地监听Socket的各种事件，从而实现对网络通信的控制和处理。

在Socket对象的事件处理程序的回调函数中，通常会传入一个参数，通常被称为data。这个data参数包含了事件触发时传递给回调函数的数据。在网络通信中，特别是在TCP连接中，data参数通常表示接收到的数据。

当监听'data'事件时，回调函数的data参数表示接收到的数据块。这些数据块可能是从服务器发送给客户端的数据，也可能是客户端发送给服务器的数据，取决于具体的通信场景。

在回调函数中，可以使用data参数来处理接收到的数据，比如对数据进行解析、处理、展示等操作。通过处理接收到的数据，可以实现客户端和服务器之间的数据交换和通信。

在Node.js中，通过Socket对象接收到的数据是一个Buffer对象。Buffer是Node.js中用于处理二进制数据的数据类型，它允许在内存中存储原始二进制数据，如字节流、文件数据等。Buffer对象可以包含各种数据，如文本、图像、音频等，以及网络通信中的原始字节数据。

通过Socket对象监听'data'事件时，回调函数的data参数就是一个Buffer对象，表示接收到的原始字节数据。需要根据具体的通信协议和数据格式，对这些Buffer数据进行解析和处理，才能正确地处理接收到的数据。

在处理接收到的数据时，可以使用Buffer对象的方法和属性，如t`oString()`方法将Buffer数据转换为字符串，slice()方法截取部分数据等。通过Buffer对象，可以方便地处理网络通信中的二进制数据。

### 写入信息：

Socket对象的write()方法用于向连接的另一端发送数据。通过write()方法，可以将数据发送到服务器或客户端，实现双向通信。write()方法接受一个参数，即要发送的数据，可以是字符串、Buffer对象或Uint8Array对象。

语法如下：
```javascript
socket.write(data, [encoding], [callback])
```

- data: 要发送的数据，可以是字符串、Buffer对象或Uint8Array对象。
- encoding: 可选参数，指定数据的编码格式，如'utf8'、'ascii'、'hex'等。
- `callback`: 可选参数，发送数据完成后的回调函数。

示例：
```javascript
socket.write('Hello, server!', 'utf8', () => {
  console.log('Data sent to server');
});
```

通过write()方法，可以向服务器发送请求数据，或向客户端发送响应数据。在网络通信中，write()方法是实现数据传输的关键方法，可以方便地实现客户端与服务器之间的数据交换。

### 发送请求

http的GET请求:

```javascript
const socket = net.createConnection({ port: 80, host: 'www.example.com' }, () => {
  console.log('Connected to server');

  // 构建HTTP请求
  const httpRequest = `GET /index.html HTTP/1.1\r\nHost: www.example.com\r\nUser-Agent: Node.js\r\n\r\n`;

  // 发送HTTP请求
  socket.write(httpRequest);
});
```

http的POST请求：

```javascript
const socket = net.createConnection({ port: 80, host: 'www.example.com' }, () => {
  console.log('Connected to server');

  // 构建HTTP请求
  const requestBody = 'name=John&age=30';
  const httpRequest = `POST /submit-data HTTP/1.1\r\nHost: www.example.com\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: ${Buffer.byteLength(requestBody)}\r\n\r\n${requestBody}`;

  // 发送HTTP请求
  socket.write(httpRequest);
});
```

> 这段内容是一个完整的HTTP POST请求的构建过程，包括请求行、请求头部和请求体。让我们逐步解释每个部分的含义：
>
> 1. 请求行（Request Line）：
>    - POST /submit-data HTTP/1.1：请求行包括请求方法（POST）、请求的URL路径（/submit-data）和HTTP协议版本（HTTP/1.1）。
>
> 2. 请求头部（Request Headers）：
>    - Host: www.example.com：指定请求的目标主机名。
>    - Content-Type: application/x-www-form-urlencoded：指定请求体的内容类型为表单形式的编码方式。
>    - Content-Length: ${Buffer.byteLength(requestBody)}：指定请求体的长度，使用Buffer.byteLength()方法获取请求体的字节长度。
>
> 3. 空行（空格行）：
>    - \r\n：空行用于分隔请求头部和请求体。
>
> 4. 请求体（Request Body）：
>    - ${requestBody}：请求体包含了实际要发送的数据，这里使用了模板字符串的方式将请求体的内容插入到HTTP请求中。
>
> 综合起来，这段内容表示了一个使用POST方法向www.example.com的/submit-data路径发送数据的HTTP请求。请求头部中包含了Content-Type指定请求体的编码方式为表单形式，Content-Length指定请求体的长度为实际请求体的字节长度。最后，请求体中包含了具体要发送的数据，这里是'name=John&age=30'。通过这样的HTTP请求，可以向服务器发送数据并实现数据交互。

注意：

在HTTP协议中，请求头部和请求体之间需要用一个空行（也就是两个换行符"\r\n\r\n"）来进行分隔。这个空行的存在是为了告诉服务器请求头部的结束位置，从而可以正确地解析请求头部和请求体。

当服务器收到一个HTTP请求时，它会首先读取请求行和请求头部，然后根据Content-Length或Transfer-Encoding等请求头部字段来确定请求体的长度或编码方式。请求头部和请求体之间的空行就是用来表示请求头部的结束，之后的内容就是请求体的数据。

如果没有正确地在请求头部和请求体之间添加空行分隔符，服务器可能会无法正确解析请求体中的数据，从而导致数据处理出现错误。因此，为了确保HTTP请求的正确解析和处理，请求头部和请求体之间需要使用两个换行符进行分隔。

### 创建服务器：

- 创建服务器
- 接受客户端消息
- 响应客户端
- 监听服务端
- 处理报错

方法：`net.createServer()`

`net.createServer()`方法是Node.js中net模块提供的用于创建TCP服务器的方法。该方法接受一个回调函数作为参数，回调函数会在每次有新的连接建立时被调用，并传入一个表示客户端与服务器之间连接的Socket对象。

在`net.createServer()`方法中，你可以设置监听器来处理客户端连接、数据接收、连接断开等事件。通过这些事件监听器，你可以实现服务器对客户端的响应和处理逻辑。

以下是`net.createServer()`方法的基本语法：

```javascript
const server = net.createServer([options][, connectionListener]);
```

- `options`：可选参数，用于配置服务器的选项。
- `connectionListener`：回调函数，接收一个表示客户端与服务器连接的Socket对象作为参数。在该回调函数中，你可以设置监听器来处理客户端连接、数据接收、连接断开等事件。

使用`net.createServer()`方法创建一个TCP服务器后，可以通过调用`server.listen()`方法指定服务器监听的端口，并在指定端口上启动服务器。通过设置连接事件的监听器，可以实现服务器对客户端连接和数据的处理逻辑。

在`net.createServer()`方法中，`options`是一个可选参数，用于配置服务器的选项。这些选项可以用来设置服务器的行为，例如指定服务器的最大连接数、超时时间、允许的IP地址等。以下是一些常用的选项：

1. `allowHalfOpen`：一个布尔值，表示是否允许半开连接。默认情况下，当客户端关闭连接时，服务器会立即关闭连接，如果设置为`true`，则允许服务器保持连接打开状态，等待客户端关闭连接。
   
2. `pauseOnConnect`：一个布尔值，表示是否在连接建立时暂停数据流。默认情况下，数据流会立即开始传输，如果设置为`true`，则在连接建立时暂停传输，直到手动恢复。

3. `maxConnections`：一个数字，表示服务器允许的最大连接数。当达到最大连接数时，新的连接将被拒绝。

4. `timeout`：一个数字，表示服务器的连接超时时间。如果客户端在指定时间内没有发起通信，服务器会自动断开连接。

5. `allowHalfOpen`：一个布尔值，表示是否允许半开连接。默认情况下，当客户端关闭连接时，服务器会立即关闭连接，如果设置为`true`，则允许服务器保持连接打开状态，等待客户端关闭连接。

这些选项可以根据需求进行配置，以满足服务器的特定需求。在创建TCP服务器时，可以根据具体情况选择是否设置这些选项，以实现更灵活和定制化的服务器行为。

### 查看和响应来自客户端的请求：

```javascript
    socket.on("data", async (data) => {
        console.log("来自客户端的请求", data.toString("utf-8"));
        const filename = path.resolve(__dirname, "./0.png");
        const HeadBuffer = Buffer.from(`HTTP/1.1 200 OK\r\nContent-Type: image/png\r\n\r\n`, "utf-8");
        const BodyBuffer = await fs.promises.readFile(filename);
        const result = Buffer.concat([HeadBuffer, BodyBuffer]);
        socket.write(result);
    })
```

