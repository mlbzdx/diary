# loader

> `webpack`做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。
> 更多的功能需要借助`webpack` loaders和`webpack` plugins完成。

`webpack` loader： loader本质上是一个函数，它的作用是将某个源码字符串转换成另一个源码字符串返回。

![](assets/2020-01-13-10-39-24.png)

loader函数的将在模块解析的过程中被调用，以得到最终的源码。

**全流程：**

![](assets/2020-01-13-09-28-52.png)

**chunk中解析模块的流程：**

![](assets/2020-01-13-09-29-08.png)

**chunk中解析模块的更详细流程：**

![](assets/2020-01-13-09-35-44.png)

**处理loaders流程：**

![](assets/2020-01-13-10-29-54.png)

**loader配置：**

**完整配置**

```js
module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: [ //匹配到后应用的规则模块
                    {  //其中一个规则
                        loader: "模块路径", //loader模块的路径，该字符串会被放置到require中
                        options: { //向对应loader传递的额外参数

                        }
                    }
                ]
            }
        ]
    }
}
```

**简化配置**

```js
module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: ["模块路径1", "模块路径2"]//loader模块的路径，该字符串会被放置到require中
            }
        ]
    }
}
```

## loader转换css代码

1. 配置 `./loaders/css-loader.js` 文件到 `webpackconfig`中，处理 符合`.css` 结尾规则的文件。
2. 在处理的 `./loaders/css-loader.js`文件中，将读取的 `css` 样式赋值给页面的style元素，将这段 `js` 代码转化为字符串(该转义的地方需要转义)，这样代码就能在编译后的环境中运行了。（不能直接将 `js` 代码写在 `./loaders/css-loader.js`中，因为编译只会在 `node`环境中运行，不会在编译后的环境中运行）。

示例代码：

配置 `webpack.config.js`:

```js
const path = require("path");
module.exports = {
  mode: "development",
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: path.resolve(__dirname, "./loaders/style-loaders.js") },
        ],
      },
    ],
  },
};

```

配置 `./loaders/css-loader.js`

```js
module.exports = (sourceCode) => {
  return `var style = document.createElement("style");
   style.innerHTML = \`${sourceCode}\`;
  document.head.appendChild(style);
  module.exports = \`${sourceCode}\``;
};
```

这样配置后，在入口文件引用的所有css文件都会经过loader进行编译而转化成打包后的 `js`代码。在引用文件到页面上时只需要引用打包后的 `js`代码所在文件即可。

## loader转换图片 

1. 配置 `./loaders/img-loader.js`到 `webpack.config.js`中去，处理几种常见的以 `.png/.jpg/.gif`等格式结尾的文件

2. 配置,如果不设置 `loader.raw` 属性，传入 `loader` 函数的就是原始的数据格式，即base64；设置后，会转化为 `Buffer`对象。

3. base64格式的数据不能直接引用到页面的`img`元素中，需要做以下处理

   > 在 HTML 页面中，可以使用 Base64 编码的图片数据作为 `img` 元素的 `src` 属性值来显示图片。以下是一个示例：
   >
   > ```html
   > <!DOCTYPE html>
   > <html>
   > <head>
   >   <title>Base64 Image Example</title>
   > </head>
   > <body>
   >   <img src="data:image/png;base64,iVBORw0KG...[Base64编码数据]..." alt="Base64 Image">
   > </body>
   > </html>
   > ```
   >
   > 在示例中，`src` 属性的值以 `data:` 开头，后面跟着图片的 MIME 类型（例如 `image/png`）和 Base64 编码的图片数据。你需要将 `[Base64编码数据]` 替换为实际的 Base64 编码图片数据。
   >
   > 请注意，使用 Base64 编码的图片数据会将图片的内容直接嵌入到 HTML 页面中，而不是通过外部链接加载。这种方式适用于较小的图片或需要避免外部资源加载的情况。然而，对于大型图片或大量图片的情况，使用外部链接加载图片可能更为合适，以避免增加页面大小和加载时间。
   >
   > 另外，如果你是在动态生成页面的服务器端代码中使用 Base64 编码的图片数据，可以通过将 Base64 数据直接嵌入到页面模板中来动态生成 `img` 元素。具体实现方法取决于你使用的服务器端技术和模板引擎。

4. 将转换后的格式使用 `module.exports`导出，并将这段转换导出的代码返回，使其最终能在编译后的环境中运行。

配置 `webpack`

```js
const path = require("path");
module.exports = {
  mode: "development",
  module: {
    rules: [
      {
        test: /\.(png)|(jpg)$/,
        use: [{ loader: path.resolve(__dirname, "./loaders/img-loaders.js") }],
      },
    ],
  },
};
```

配置加载器 `./loader/img-loader.js`：

```js
module.exports = (sourceCode) => {
  const content = "data:image/png;base64," + sourceCode.toString("base64");
  return `module.exports = \`${content}\``;
};
module.exports.raw = true;//把加载器函数的静态属性raw配置为true,参数sourceCode即为Buffer对象
```

