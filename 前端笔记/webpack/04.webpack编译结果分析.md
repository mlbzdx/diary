首先，在 `src` 目录下新建了两个文件，如下：

`./src/index.js`:

```javascript
    console.log("index Modlue");
    var a = require("./src/a.js");
    console.log(a);
```

`./src/a.js`:

```javascript
    console.log("a module");
    module.exports = "a";
```

现在运行 `webpack`命令进行打包

打包后的 `main.js` 文件简化后如下：

```javascript
// 负责模块处理的立即执行函数
((__webpack_modules__) => {
  //声明模块缓存
  var __webpack_module_cache__ = {};
  // 声明require函数 传入模块Id 即模块的唯一路径
  function __webpack_require__(moduleId) {
    // 检查模块是否在缓存里
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    // 创建一个新的模块(并且将新模块赋值给模块缓存，即__webpack_module_cache__)
    var module = (__webpack_module_cache__[moduleId] = {
      // no module.id needed
      // no module.loaded needed
      exports: {},
    });

    // 调用相应moduleId对应的模块函数，并将module,modlue.exports,require方法传递给模块运行函数
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);

    // 返回模块导出的结果
    return module.exports;
  }

  // startup
  // Load entry module and return exports
  // This entry module can't be inlined because the eval devtool is used.
  // 调用require函数，传入模块的入口文件
  var __webpack_exports__ = __webpack_require__("./src/index.js");
})(
  /* 通过将模块对象以参数的形式传入模块处理的立即执行函数，可以避免模块对象和模块处理函数声明变量来污染全局环境 */ {
    "./src/a.js": (module) => {
      // 通过eval可以执行转换为字符串的代码，并且可以可以单独开启一个环境运行模块中的代码，同时还可以通过 # sourceURL= path 指明代码所在文件路径，便于运行报错后的调试。
      eval(
        'console.log("a module");\r\nmodule.exports = "a";\r\n\n\n//# sourceURL=webpack://test/./src/a.js?'
      );
    },

    "./src/index.js": (
      /* 传入的参数实际为module,modlue.exports,require */
      __unused_webpack_module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      eval(
        'console.log("index Modlue");\r\nvar a = __webpack_require__(/*! ./a */ "./src/a.js");\r\nconsole.log(a);\r\n\n\n//# sourceURL=webpack://test/./src/index.js?'
      );
    },
  }
);
```

编译解析：

1. 编译解析的所有过程都在负责模块处理的立即执行函数中运行，避免污染全局变量
2. 每个模块都会被保存在模块对象中，以相对于 `src`的相对路径作为模块id (`moduleId`),而模块中运行的代码封装为模块对象的方法，模块id作为方法名。
3. 模块对象可以直接在模块处理的立即执行函数中声明，也可以作为参数传入模块处理函数中，这样可以避免变量额外的变量声明带来的全局污染。
4. `webpack`首先声明了模块缓存（` __webpack_module_cache__`），先判断模块是否已经运行过，如果运行过，则直接返回缓存的结果，如果没有那么创建一个新的模块并赋值给模块缓存。
5. 在模块处理函数中定义了 `require`函数并对其进行了调用，`webpack` 将该函数命名为 `__webpack_require__`。通过将模块的唯一id传递给该函数，会调用模块对象中模块的对应方法，从而运行模块中的代码。调用 `__webpack_require__`模块时，传入的是默认的入口文件 `./src/index.js`
6. 在 `__webpack_require__`函数中，声明了 `module`,以及 `module`对象中的 `exports`，并将这些有关导出的变量以及函数本身作为参数，传递给了模块对应的方法。在模块方法运行，对模块导出内容作出一些操作后，`__webpack_require__`函数将最终的 `module.exports`返回。
7. 在封装模块里运行的代码时，采用的 `eval`方法，该方法会启用单独的环境运行代码，因此在发生报错后便于去除无关环境的代码单独进行调试。同时，通过设置 `sourceURL`还可以指名模块报错的路径，利于索引到源文件位置进行修改。