# 远程获取数据

## XHR API

```js
var xhr = new XMLHttpRequest(); //创建发送请求的对象
xhr.onreadystatechange = function(){ //当请求状态发生改变时运行的函数
    // xhr.readyState： 一个数字，用于判断请求到了哪个阶段
    // 0: 刚刚创建好了请求对象，但还未配置请求（未调用open方法）
    // 1: open方法已被调用
    // 2: send方法已被调用
    // 3: 正在接收服务器的响应消息体
    // 4: 服务器响应的所有内容均已接收完毕
    
    // xhr.responseText： 获取服务器响应的消息体文本

    // xhr.getResponseHeader("Content-Type") 获取响应头Content-Type
}
xhr.open("请求方法", "url地址"); //配置请求
xhr.setRequestHeader("Content-Type", "application/json"); //设置请求头
xhr.send("请求体内容"); //构建请求体，发送到服务器，如果没有请求体，传递null
```

## Fetch API

`fetch()` 是一个用于发起网络请求的 JavaScript 函数。它是现代浏览器提供的原生方法，用于替代传统的 `XMLHttpRequest`（XHR）对象，提供了更简洁、灵活和强大的功能。

`fetch()` 函数使用 Promise 对象来处理异步操作，并返回一个表示响应的 Promise。它的基本语法如下：

```javascript
fetch(url [, options])
  .then(response => {
    // 处理响应
  })
  .catch(error => {
    // 处理错误
  });
```

参数说明：
- `url`：请求的 URL 地址。
- `options`（可选）：一个可配置的对象，用于指定请求的各种选项，例如请求方法、请求头、请求体等。

返回值：
`fetch()` 函数返回一个 Promise 对象，该 Promise 对象在请求完成后被解析，以包含表示响应的 Response 对象。你可以使用 `.then()` 方法处理响应，或使用 `.catch()` 方法处理错误。

用例示例：
```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (response.ok) {
      return response.json(); // 将响应解析为 JSON
    } else {
      throw new Error('请求失败');
    }
  })
  .then(data => {
    console.log(data); // 处理响应数据
  })
  .catch(error => {
    console.error(error); // 处理错误
  });
```

在上述示例中，我们使用 `fetch()` 函数发起了一个 GET 请求，并传递了一个 URL。然后，我们使用 `.then()` 方法处理响应，并检查响应的状态码是否为成功状态（`response.ok`）。如果成功，我们使用 `.json()` 方法将响应解析为 JSON 格式。最后，我们使用 `.then()` 方法处理解析后的数据，或使用 `.catch()` 方法处理任何错误。

`fetch()` 还可以通过设置 `options` 参数来配置请求的各种选项，例如请求方法、请求头、请求体等。

```javascript
const resp = await fetch('url地址', { // 请求配置对象，可省略，省略则所有配置为默认值
  method: '请求方法', // 默认为GET
  headers: { // 请求头配置
    'Content-Type': 'application/json',
    'a': 'abc' 
  },
  body: '请求体内容' // 请求体
}); // fetch会返回一个Promise，该Promise会在接收完响应头后变为fulfilled

resp.headers; // 获取响应头对象
resp.status; // 获取响应状态码，例如200
resp.statusText; // 获取响应状态码文本，例如OK
resp.json(); // 用json的格式解析即将到来的响应体，返回Promise，解析完成后得到一个对象
resp.text(); // 用纯文本的格式解析即将到来的响应体，返回Promis，解析完成后得到一个字符串
```

那么为什么在获取解析后的请求体的过程中，需要调用两次 `then()`方法？这时因为第一次调用后需要对返回的请求体数据进行 `json`格式的解析，`res.json` 返回仍然是一个 `promise`对象，所以还需要进行调用一下 `then()`方法。

> 补充：`json()` 是 `fetch()` 函数返回的 `Response` 对象的一个方法，用于将响应的主体内容解析为 JSON 格式。
>
> `json()` 方法没有参数，它会自动解析响应的主体内容，并返回一个 Promise 对象。当 Promise 对象被解析时，它包含了解析后的 JSON 数据。
>
> 用例示例：
> ```javascript
> fetch('https://api.example.com/data')
>   .then(response => response.json())
>   .then(data => {
>     console.log(data); // 处理解析后的 JSON 数据
>   })
>   .catch(error => {
>     console.error(error); // 处理错误
>   });
> ```
>
> 在上述示例中，我们使用 `fetch()` 函数发起了一个 GET 请求，并使用 `.json()` 方法将响应解析为 JSON 格式。然后，我们使用 `.then()` 方法处理解析后的数据，并在控制台打印出来。
>
> `json()` 方法返回的是一个新的 Promise 对象，因此你可以使用 `.then()` 方法来处理解析后的数据，或使用 `.catch()` 方法处理任何错误。
>
> 需要注意的是，`json()` 方法只能在响应的主体内容是有效的 JSON 格式时才能成功解析。如果主体内容不是有效的 JSON 格式，解析过程将会失败，导致 Promise 对象被拒绝（rejected）。在这种情况下，你可以使用 `.catch()` 方法来捕获并处理解析错误。
>

总之，`fetch()` 是一个用于发起网络请求的原生 JavaScript 函数，它返回一个 Promise 对象，并提供了灵活的选项来配置请求。你可以使用 `.then()` 方法处理响应数据，或使用 `.catch()` 方法处理错误。

## `Axios`

> 官网：https://axios-http.com/zh/
>
> CDN：https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js

`axios`是一个请求库，在浏览器环境中，它封装了XHR，提供更加便捷的API发送请求

### 基本使用

#### 发送请求

```js
// 发送 get 请求到 https://study.duyiedu.com/api/herolist，输出响应体的内容
axios.get("https://study.duyiedu.com/api/herolist").then(resp=>{
  console.log(resp.data); // resp.data 为响应体的数据，axios会自动解析JSON格式
})

// 发送 get 请求到 https://study.duyiedu.com/api/user/exists?loginId=abc，输出响应体的内容
axios.get("https://study.duyiedu.com/api/user/exists", {
  params: { // 这里可以配置 query，axios会自动将其进行Url编码
    loginId: "abc"
  },
}).then(resp=>{
  console.log(resp.data); // resp.data 为响应体的数据，axios会自动解析JSON格式
})

// 发送 post 请求到 https://study.duyiedu.com/api/user/reg
// axios 会将第二个参数转换为JSON格式的请求体
axios.post("https://study.duyiedu.com/api/user/reg", {
  loginId: 'abc',
  loginPwd: '123123',
  nickname: '棒棒鸡'
}).then(resp=>{
  console.log(resp.data); // resp.data 为响应体的数据，axios会自动解析JSON格式
})
```

`axios`的基本用法为：

```js
axios.get(url地址, [请求配置]);
axios.post(url地址, [请求体对象], [请求配置]);

// 或直接使用 axios 方法，在请求配置中填写请求方法
axios(请求配置);
```

#### 获取响应

```js
axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);//获取响应体
    console.log(response.status);//获取响应状态码
    console.log(response.statusText);//获取响应状态码文本
    console.log(response.headers);//获取响应头
    console.log(response.config);//获取响应头配置
  });
```



### 实例

`axios`允许开发者先创建一个实例，后续通过使用实例进行请求

这样做的好处是可以预先进行某些配置

示例：

```js
// 创建实例
const instance = axios.create({
  baseURL: 'https://study.duyiedu.com/'
});

// 发送 get 请求到 https://study.duyiedu.com/api/herolist，输出响应体的内容
instance.get("/api/herolist").then(resp=>{
  console.log(resp.data); // resp.data 为响应体的数据，axios会自动解析JSON格式
})
```

### 拦截器

有时，我们可能需要对所有的请求或响应做一些统一的处理

比如，在请求时，如果发现本地有token，需要附带到请求头

又比如，在拿到响应后，我们仅需要取响应体中的data属性

再比如，如果发生错误，我们需要做一个弹窗显示

**这些统一的行为就非常适合使用拦截器**

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // config 为当前的请求配置
  // 在发送请求之前做些什么
  // 这里，我们添加一个请求头
  const token = localStorage.getItem('token');
  if(token){
    config.headers.authorization = token;
  }
  return config; // 返回处理后的配置
});

// 添加响应拦截器
axios.interceptors.response.use(function (resp) {
  // 2xx 范围内的状态码都会触发该函数。
  // 对响应数据做点什么
  return resp.data.data; // 仅得到响应体中的data属性
}, function (error) {
  // 超出 2xx 范围的状态码都会触发该函数。
  // 对响应错误做点什么
  alert(error.message); // 弹出错误消息
});
```

设置好拦截器后，后续的请求和响应都会触发对应的函数

拦截器可以针对`axios`实例进行设置

