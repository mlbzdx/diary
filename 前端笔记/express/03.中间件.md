## 简介：

调用 `express`应用实例的请求处理方法时，需要传入匹配请求的路径和处理函数，这个处理函数就是中间件。对于同一请求，可能触发的中间件(处理函数)不止一个。

## 中间件处理流程：

![](https://mlbzdx.oss-cn-chengdu.aliyuncs.com/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

1. 一个中间件处理完成后，需要手动调用 `next()`方法，才会处理后续的中间件。

```javascript
const express = require("express");
const app = express();
const port = 3000;
app.get(
  "/api",
  (res, req, next) => {
    console.log("正在调用处理函数1");
    next();
  },
  (res, req, next) => {
    console.log("正在调用处理函数2");
    next();
  }
);

app.get("/api", (res, req, next) => {
  console.log("正在调用处理函数3");
  next();
});

app.listen(port, () =
           > {
  console.log(`正在监听端口：${port}`);
});

```

3. 如果所有的中间件直到最后一个都没有处理响应（返回状态码并结束响应），那么会返回 状态码`404`

4. 如果已经有了一个中间件处理了响应(调用了 `res.end()`方法)，那么后续的中间件仍会继续运行，但是处理响应（res）的方法设置无效。

5. 如果中间件中有任意一个中间件报了错，那么将错误作为参数传递给 `next()`方法并调用，后续的中间件会正常执行，并将错误继续传递，最后会返回状态码500。

中间件函数参数结构：

```javascript
//普通的中间件
(req, res) => {
    console.log("正在调用处理函数1");
    res.status = "200";
    res.end();
  },
//跳转处理中间件
(req, res, next) => {
    console.log("正在调用处理函数1");
    res.status = "200";
    res.end();
    next();
  },
//传入错误参数的中间件
(err,req, res, next) => {
    console.log("正在调用处理函数1");
    res.status = "200";
    res.end();
    next();
  },      
```

* `err` 中间件运行中发送的错误或者前面中间件传递的错误
* `req` 来自客户端的请求信息
* `res` 服务器可以进行的响应配置
* `next` 手动跳转下一个中间件进行处理的函数

中间件一般在 `app.use()`中使用

```javascript
app.use("url",(err,req, res, next) => {
    console.log("正在调用处理函数1");
    res.status = "200";
    res.end();
    next();
  })
```

## 常用中间件

### 封装响应中间件

#### 自定义错误处理中间件：

1. 在 `/routes`目录下创建 `errHandleMiddle.js`（将会在该文件里创建错误处理中间件函数并导出）

2. 导出的中间件函数需要传入中间件处理函数完整的参数结构，即：

   ```javascript
   (err, req, res, next) => {
     ...
   };
   ```

3. 逻辑上先判断前面的中间件函数处理过程中是否有报错，并将错误传入。然后根据有无错误来封装不同的响应结构给客户端。实例如下：

   ```javascript
   // 错误处理中间件
   module.exports = (err, req, res, next) => {
     if (err) {
       const errObj = {
         code: "500",
         msg: err instanceof Error ? err.message : err,
       };
       res.status(500).send(errObj);
     } else {
       next();
     }
   };
   ```

   在这里我们选择如果报错那么返回状态码500，并将报错信息（错误的类型不定，所以这里用了 `instance` 方法进行了判断 ）。返回的消息结构为 `errObj`对象。

4. 创建express应用实例，测试一下该错误处理中间件。

   ```javascript
   // 导入express
   const express = require("express");
   // 创建express应用实例
   const app = express();
   // 处理请求与学生相关的api中间件
   app.get("/api/student", (req, res, next) => {
     //手动抛出传递错误
     next(new Error("abc"));
   });
   // 添加错误处理中间件
   app.use(require("./errHandleMiddle.js"));
   // 开启端口，监听请求
   const port = 3000;
   app.listen(port, () => {
     console.log(`正在监听端口：${port}`);
   });
   
   ```

5. 在客户端查看响应体，即可看见该中间件成功的将请求的错误发生的原因`abc`发送到了客户端。

#### 自定义封装响应消息函数

在 `/routes`目录下创建 `wrapperResponseMsg.js`文件，该文件中定义一个中间件函数，负责将返回给客户端的数据或错误进行封装后返回。

```javascript
exports.wrapperResponseMsg = (data) => {
  return {
    code: 0,
    msg: "",
    data,
  };
};
exports.wrapperErrMsg = (errCode = 500, err = "server internal error") => {
  return {
    code: errCode,
    msg: err,
  };
};
```

下面是将从 `mysql`数据库查询到的学生信息数据进行封装并返回给客户端的例子。

```javascript
const express = require("express");
const router = express.Router();
const studentSev = require("../../service/studentSev");
const { async } = require("validate.js");

// 处理获取全部学生的请求
router.get("/", async (req, res, next) => {
  // 获取请求路径的参数
  const { page, limit, name, sex } = req.query;
  const result = await studentSev.findStudent(page, limit, "", name, sex);
  const { wrapperResponseMsg } = require("../wrapperResponseMsg");
  res.send(wrapperResponseMsg(result));
});
module.exports = router;
```

这样将返回如下的消息格式给客户端：

```javascript
{
    "code": 0,
    "msg": "",
    "data": {}
}
```

上面的错误处理中间件也可以通过该函数进行如下优化：

```javascript
// 错误处理中间件
module.exports = (err, req, res, next) => {
  if (err) {
    err instanceof Error ? err.message : err;
    const { wrapperErrMsg } = require("./wrapperResponseMsg");
    res.status(500).send(wrapperErrMsg("", err));
  } else {
    next();
  }
};
```

#### 自定义异步处理报错的封装函数

尽管已经对返回给客户端的响应数据或响应错误进行了封装，但是，如果在请求处理中发生的异步报错，`express`的 `next()`方法目前还不支持传递给后续中间件，所以会导致出现中间件处理不了异步报错的情况。因此需要对中间件函数进行封装，使其能够处理传递异步请求中的报错。

在定义异步请求的封装函数之前，介绍一下遇到异步报错的情况首先可以通过下面的方式来解决：

```javascript
try{}
catch(err){}
```

现在通过 `validate`会对添加学生到数据库的请求数据进行验证，如果格式不正确，就会在异步执行中报错并返回错误。这时就可以通过上面的方法来解决异步报错问题，继续传递错误消息，如下：

```javascript
// 处理添加学生的请求
router.post("/", async (req, res, next) => {
  try {
    const reslut = await studentSev.addStudent(req.body);
    res.send(wrapperResponseMsg(reslut));
  } catch (err) {
    next(err);
  }
});
```

但是每一个都这样书写会增加代码书写的工作量，所以这里选择对异步报错的处理进行函数封装。

如下：

```javascript
const { async } = require("validate.js");
const { wrapperResponseMsg } = require("./wrapperResponseMsg");
module.exports = (handler) => {
  return async (req, res, next) => {
    try {
      const reslut = await handler(req, res, next);
      res.send(wrapperResponseMsg(reslut));
    } catch (err) {
      next(err);
    }
  };
};

```





### 静态资源中间件

#### `express.static()`

在Express框架中，`express.static()`是一个内置的中间件函数，用于提供静态文件的服务。它会根据指定的目录路径，将静态文件（如HTML、CSS、JavaScript、图像等）发送给客户端。

`express.static()`的基本语法如下：

```javascript
express.static(root, [options])
```

参数说明：

- `root`：指定静态文件所在的根目录路径(静态资源一般位于项目工程的`public`目录下)。
- `options`（可选）：一个对象，用于配置静态文件的选项。常见的选项包括：
  - `maxAge`：指定静态文件的缓存时间（以毫秒为单位）。
  - `etag`：指定是否启用`ETag`响应头，默认为`true`。
  - `lastModified`：指定是否启用Last-Modified响应头，默认为`true`。
  - `redirect`：指定是否在缺少斜杠时重定向到带有斜杠的路径，默认为`true`。
  - `index`：指定默认的索引文件名，当请求的路径是一个目录时使用（一般一开始为`public/index.html`文件）。

返回值：

- `express.static()`函数返回一个中间件函数，可以通过`app.use()`来注册它。

下面是一个示例，演示了如何使用`express.static()`来提供静态文件服务：

```javascript
// 导入express
const express = require("express");
// 创建express应用实例
const app = express();
// 添加静态资源处理中间件
const path = require("path");
const staticPath = path.resolve(__dirname, "../public");
// 开启端口，监听请求
const port = 3000;
app.listen(port, () => {
  console.log(`正在监听端口：${port}`);
});

```

在这个例子中，我们有一个名为`public`的目录，其中包含一些静态文件，如`index.html`、`styles.css`和`logo.png`。我们使用`express.static()`中间件函数将`public`目录注册到应用程序中。这样，当客户端请求`/index.html`、`/styles.css`或`/logo.png`时，Express会自动在`public`目录下查找相应的文件并发送给客户端。

通过使用`express.static()`中间件，你可以轻松地提供静态文件服务，如网页、样式表、脚本和图像等。这在构建Web应用程序时非常有用，因为它允许你将静态资源与动态路由处理分开，并提高应用程序的性能和可维护性。

### 请求体解析中间件

#### `express.urlencoded()`

在Express框架中，`express.urlencoded()`是一个内置的中间件函数，用于解析URL编码的请求体。它可以将通过POST请求发送的表单数据解析为JavaScript对象。

`express.urlencoded()`的基本语法如下：

```javascript
express.urlencoded([options])
```

参数说明：

- `options`（可选）：一个对象，用于配置URL编码解析的选项。常见的选项包括：
  - `extended`：指定是否使用`querystring`库来解析URL编码，默认为`true`。如果设置为`false`，则使用`querystring`库的`parse()`方法解析URL编码。

返回值：

- `express.urlencoded()`函数返回一个中间件函数，可以通过`app.use()`来注册它。

下面是一个示例，演示了如何使用`express.urlencoded()`来解析URL编码的请求体：

```javascript
const express = require('express');
const app = express();

// 注册URL编码解析中间件
app.use(express.urlencoded({ extended: true }));

// 路由处理程序
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  // 在这里处理登录逻辑
});

// 启动服务器
app.listen(3000, () => {
  console.log('Server is listening on port 3000');
});
```

在这个例子中，我们使用`express.urlencoded()`中间件函数将URL编码解析注册到应用程序中。然后，我们定义了一个处理`/login`路由的POST请求的路由处理程序。当客户端发送一个POST请求到`/login`时，中间件函数会解析请求体中的URL编码数据，并将其作为`req.body`对象的属性提供给后续的路由处理程序。在这个例子中，我们可以通过`req.body.username`和`req.body.password`访问表单中的用户名和密码。

通过使用`express.urlencoded()`中间件，你可以方便地处理通过POST请求发送的URL编码数据，如表单提交。它简化了从请求体中提取数据的过程，并使你能够轻松地处理表单数据的验证、存储和其他业务逻辑。

#### `express.json()`

在Express框架中，`express.json()`是一个内置的中间件函数，用于解析JSON格式的请求体。它可以将通过POST请求发送的JSON数据解析为JavaScript对象。

`express.json()`的基本语法如下：

```javascript
express.json([options])
```

参数说明：

- `options`（可选）：一个对象，用于配置JSON解析的选项。常见的选项包括：
  - `inflate`：指定是否启用`Gzip`和`Deflate`压缩算法，默认为`true`。
  - `limit`：指定请求体的大小限制，默认为`'100kb'`。
  - `reviver`：指定一个自定义的解析器函数，用于修改解析后的JSON对象。
  - `strict`：指定是否只接受数组或对象作为顶级结构，默认为`true`。
  - `type`：指定要解析的Content-Type，默认为`'application/json'`。

返回值：

- `express.json()`函数返回一个中间件函数，可以通过`app.use()`来注册它。

下面是一个示例，演示了如何使用`express.json()`来解析JSON格式的请求体：

```javascript
const express = require('express');
const app = express();

// 注册JSON解析中间件
app.use(express.json());

// 路由处理程序
app.post('/data', (req, res) => {
  const { name, age } = req.body;
  // 在这里处理数据
});

// 启动服务器
app.listen(3000, () => {
  console.log('Server is listening on port 3000');
});
```

在这个例子中，我们使用`express.json()`中间件函数将JSON解析注册到应用程序中。然后，我们定义了一个处理`/data`路由的POST请求的路由处理程序。当客户端发送一个POST请求到`/data`时，中间件函数会解析请求体中的JSON数据，并将其作为`req.body`对象的属性提供给后续的路由处理程序。在这个例子中，我们可以通过`req.body.name`和`req.body.age`访问JSON数据中的名称和年龄。

通过使用`express.json()`中间件，你可以方便地处理通过POST请求发送的JSON数据。它简化了从请求体中提取数据的过程，并使你能够轻松地处理JSON数据的验证、存储和其他业务逻辑。

### 路由处理中间件

> 详见  [04.express路由.md](04.express路由.md) 

### cookie处理中间件

> 详见 [07.cookie应用（登录与认证）.md](07.cookie应用（登录与认证）.md) 
