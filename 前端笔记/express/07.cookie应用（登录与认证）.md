## 身份验证和授权中间件

身份验证和授权涉及到网站的登录，与 `cookie`紧密相关

> 使用第三方库解析cookie
>
> cookie解析 `cookie-parser`：https://github.com/expressjs/cookie-parser#readme
>
> 路径正则转换 `path-to-regexp`:https://github.com/pillarjs/path-to-regexp#readme

### 使用 `cookie-parser`中间件

`cookie-parser`是一个处理 `cookie` 的中间件，安装导入后进行调用返回一个中间件。示例如下：

```javascript
// 添加cookie-parser中间件
// 添加后，会往中间件处理函数中的req对象中注入cookies属性，用来获取来自客户端的cookie
// 添加后，会往中间件处理函数中的res对象中注入cookie方法，用来设置响应给客户端的cookie
const cookieParser = require("cookie-parsers");
app.use(cookieParser()); 
```

### 设置响应给客户端的 `token`

`res`方法包括三个参数：

* 设置的cookie 键名
* 设置的 cookie 键值
* 设置的 cookie 配置选项，包括
  * `domain` cookie主域
  * `path`  路径
  * `maxAge`  cookie保存时长等等

下面是一段设置cookie的代码实例：

```javascript
async (req, res) => {
    const { loginId, loginPwd } = req.body;

    const result = await adminSev.login(loginId, loginPwd);
    if (result) {
      res.cookie("token", result.id, {
        domain: "localhost",
        path: "/",
        maxAge: 3600 * 1000,
      });
    }
    return result;
  }
```

### 验证来自客户端的 `token`

一般情况下，将token的值设置为 `cookie`的值，但是`cookie` 支持浏览器，如果是其他设备访问就不能进行授权验证了，因此一般还会为请求头中加入 `authentication`来处理其他设备的验证。

所以这里可以定义授权验证的中间件：

```javascript
module.exports = (req, res, next) => { 
  let token = ""; 
  //将cookies的值赋值给token
  cookie = req.cookies;
  if (!token) { 
    //判断是否有cookie,没有就将authorization的值赋值给token
    token = req.headers.authorization;
  }
  if (!token) { 
    //没有cookie就封装一下返回的响应消息，直接返回
    handleNoToken(req, res, next);
    return;
  }
  //有cookie就交给后续中间件进行cookie值的验证
  next();
};
const { wrapperErrMsg } = require("./wrapperResponseMsg");
function handleNoToken(req, res, next) {
  res.status(403).send(wrapperErrMsg(403, "you have no token to access api"));
}
```

### 添加验证名单

由于不是所有的路由页码都需要授权验证后才能访问，因此要为需要授权进行验证的路由添加记录名单。

在进行授权验证之前还需要添加路由授权验证，即满足条件的路由才进行授权验证，不满足的路由不用进行授权验证。

这里就需要对路由方法以及路由的参数等进行验证，涉及利用正则表达式进行辅助验证，推荐使用第三方库 `path-to-regexp`生成验证的正则表达式。在授权验证的中间件中添加验证名单：

```javascript
...
const { pathToRegexp } = require("path-to-regexp");
const needTokenApi = [
  { method: "POST", path: "/api/student" },
  { method: "PUT", path: "/api/student:id" },
];

module.exports = (req, res, next) => {
  const apis = needTokenApi.filter((api) => {
    return api.method === req.method && pathToRegexp(api.path).test(req.path);
  });
  if (apis.length === 0) {
    next();
    return;
  }
  let token = "";
  token = req.cookies.token;
...
```

### `token` 加密

在登录中，不论是账号还是密码最好不要明文存储，所以可以通过算法进行加密，加密后进行存储。

#### 加密方法一：

`cookie-parser`提供了一种加密的方式。

首先，在使用该中间件时，提供加密密钥（字符串）。

```javascript
app.use(cookieParser("mlbzdx"));
```

然后，在使用`res.cookie`方法响应给客户端 `cookie`时，使用，配置 ` signed:true`，表示对传递给客户端的`cookie`进行加密。

```
res.cookie("token", result.id, {
     domain: "localhost",
     path: "/",
     maxAge: 3600 * 1000, 
     signed:true
});
```

加密后，就不能像之前通过 `req.cookies`的属性来获取加密后的 `cookie`了，因此，需要通过 `req.signedCookies`属性来获取 `cookie`。

但这种加密方法有缺陷，即只能给浏览器的 `cookie` 进行加密，对于其他种类的客户端不友好，例如我们设置的 `authentication` 授权验证方式就不能通过这种方法进行加密。

推荐下面的加密方式二，手动进行对称加密

#### 加密方式二：

在 `utlils`目录下新建 `crypt.js`文件，创建两个方法并导出，一个用于加密 `encrypt`,一个用于 解密`decrypt`。

首先，加密使用对称加密 `aes` 算法，需要准备固定的128位的密钥。可以通过以下方式生成：

准备长度位16位的字符串。通过下面的方法来随机生成，并转换位 `Buffer`模式从而生成128位的密钥。然后保存在 `secert`变量中。

```javascript
const str = Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8);
const secert = Buffer.from(str);
```

然后准备一个随机的向量 `iv`，可以通过下面的方式来随机生成：

```javascript
const iv = Buffer.from(
  Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8)
);
```

借助 `node` 的内置库 `crypto` 进行加密。

导入 `crypto`后，可以通过下面的方法在控制台查看可以使用的加密算法。

```javascript
const crypto = require("crypto");
console.log(crypto.getCiphers());
```

加密

```javascript
exports.encrypt = (str) => {
  const cry = crypto.createCipheriv("aes-128-cbc", secert, iv);
  let result = cry.update(str, "utf-8", "hex");
  result += cry.final("hex");
  return result;
};
```

解密：

```
exports.decrypt = (str) => {
  const decry = crypto.createDecipheriv("aes-128-cbc", secert, iv);
  let result = decry.update(str, "hex", "utf-8");
  result += decry.final("utf-8");
  return result;
};
```





