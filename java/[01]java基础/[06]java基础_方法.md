# **Java 方法详解（定义、调用、重载、递归及核心知识点）**

Java 方法是程序的基本构造单元，用于实现代码复用、模块化和逻辑封装。以下是关于方法的详细解析。

---

## **一、方法的定义与声明**

### **1. 方法的概念**
方法（Method）是一段**可重用的代码块**，用于完成特定功能。通过方法可以实现代码复用和模块化编程，使程序结构更加清晰。

### **2. 方法的声明格式**
```java
[访问修饰符] [返回值类型] 方法名([参数列表]) {
    // 方法体（语句块）
    [return 返回值;] // 若返回值类型为 void，则无 return 语句
}
```
- **访问修饰符**：控制方法的访问权限（如 `public`、`private`，默认是 `package-private`）。
- **返回值类型**：方法执行后返回结果的类型（如 `int`、`String`）；若无返回值，用 `void`。
- **方法名**：遵循小驼峰命名法（如 `calculateSum`）。
- **参数列表**：定义方法接收的输入（可多个，格式为 `类型 参数名`，用逗号分隔）。
- **方法体**：包含实现功能的代码块。

---

### **3. 核心概念：形参 vs 实参**
| **概念**             | **定义**                             | **位置**           |
| -------------------- | ------------------------------------ | ------------------ |
| **形参（形式参数）** | 方法声明时定义的参数，用于接收输入值 | 方法名后的括号内   |
| **实参（实际参数）** | 方法调用时传入的具体值或变量         | 方法调用时的括号内 |

#### **示例**
```java
// 方法声明：形参 a 和 b
public static int add(int a, int b) {
    return a + b;
}

public static void main(String[] args) {
    int x = 5, y = 3;
    // 方法调用：实参 x 和 y
    int result = add(x, y);
    System.out.println(result); // 输出：8
}
```

---

## **二、方法的调用与返回值**

### **1. 方法调用方式**
#### **（1）静态方法调用**
通过 `类名.方法名()` 调用（适用于 `static` 方法）。
```java
public class MathUtils {
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
}

// 调用静态方法
int result = MathUtils.max(10, 20); // 输出：20
```

#### **（2）实例方法调用**
通过创建对象后，用 `对象名.方法名()` 调用（适用于非 `static` 方法）。
```java
public class Person {
    public void sayHello() {
        System.out.println("Hello");
    }
}

// 调用实例方法
Person p = new Person();
p.sayHello(); // 输出：Hello
```

---

### **2. 返回值与返回值类型**
- **返回值**：方法执行后的结果，通过 `return` 语句返回。
- **返回值类型**：必须与方法声明的类型一致；`void` 表示无返回值，无需 `return`。

#### **示例**
```java
// 有返回值（int 类型）
public static int multiply(int a, int b) {
    return a * b; // 返回计算结果
}

// 无返回值（void 类型）
public static void printInfo(String name) {
    System.out.println("Name: " + name);
    // 可选：return; 表示结束方法
}
```

---

## **三、方法重载（Overload）**

### **1. 方法重载的概念**
方法重载是指**同一个类中**，方法名相同但**参数列表不同**的多个方法。重载的目的是让方法名更简洁，根据参数自动匹配不同实现。

---

### **2. 重载的规则**
- 参数列表必须不同（满足以下任意一条即可）：
  - **参数个数不同**；
  - **参数类型不同**；
  - **参数顺序不同**（不建议使用，影响可读性）。
- **注意**：仅返回值类型不同、访问修饰符不同，**不能构成重载**。

---

### **3. 示例**
```java
public class Calculator {
    // 方法 1：两个 int 相加
    public static int add(int a, int b) {
        return a + b;
    }

    // 方法 2：三个 int 相加（参数个数不同）
    public static int add(int a, int b, int c) {
        return a + b + c;
    }

    // 方法 3：两个 double 相加（参数类型不同）
    public static double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        System.out.println(add(1, 2));       // 调用方法 1 → 输出：3
        System.out.println(add(1, 2, 3));   // 调用方法 2 → 输出：6
        System.out.println(add(1.5, 2.5));  // 调用方法 3 → 输出：4.0
    }
}
```

---

## **四、递归（Recursion）**

### **1. 递归的概念**
递归是指**方法自己调用自己**的一种编程技巧，适用于解决可以分解为**重复子问题**的问题（如阶乘、斐波那契数列）。

---

### **2. 递归的基本结构**
```java
public 返回值类型 递归方法(参数) {
    if (终止条件) { // 基线条件：停止递归
        return 结果;
    } else { // 递归条件：调用自身，缩小问题规模
        return 递归方法(简化后的参数);
    }
}
```
- **终止条件**：防止无限递归（必须有，否则会栈溢出）。
- **递归条件**：将原问题分解为更小的子问题。

---

### **3. 示例**
#### **示例 1：计算 n 的阶乘**
```java
public static int factorial(int n) {
    if (n == 1) { // 终止条件：1! = 1
        return 1;
    } else { // 递归条件：n! = n × (n-1)!
        return n * factorial(n - 1);
    }
}

// 调用：计算 5!
System.out.println(factorial(5)); // 输出：120（5×4×3×2×1）
```

#### **示例 2：打印 1~n 的数字**
```java
public static void printNumbers(int n) {
    if (n == 0) { // 终止条件：n=0 时停止
        return;
    }
    printNumbers(n - 1); // 递归调用
    System.out.println(n); // 输出数字
}

// 调用：打印 1~5
printNumbers(5); // 输出：1 2 3 4 5
```

---

## **五、补充知识点**

### **1. 值传递机制**
Java 方法参数是**值传递**：
- **基本类型**：传递值的副本（修改形参不影响实参）。
- **引用类型**：传递引用的副本（修改对象内容会影响实参，重新赋值引用不影响）。

#### **示例**
```java
public static void swap(int x, int y) {
    int temp = x;
    x = y;
    y = temp; // 修改形参，不影响实参
}

public static void main(String[] args) {
    int a = 1, b = 2;
    swap(a, b);
    System.out.println(a + "," + b); // 输出：1,2（实参未交换）
}
```

---

### **2. 方法递归的限制**
递归会占用方法调用栈，递归深度过大可能导致栈溢出（`StackOverflowError`）。解决方法：
- 使用迭代（循环）替代递归。
- 优化递归逻辑，减少深度。

---

### **3. 重载与重写的区别**
| **特性** | **重载（Overload）**           | **重写（Override）**                   |
| -------- | ------------------------------ | -------------------------------------- |
| **场景** | 同一类中，方法名相同、参数不同 | 父子类中，方法名、参数、返回值完全一致 |
| **目的** | 方便调用（同一功能的不同实现） | 子类覆盖父类方法（实现多态）           |
| **权限** | 无限制                         | 子类权限 ≥ 父类权限                    |

---

## **六、总结**

| **核心知识点** | **关键内容**                                                 |
| -------------- | ------------------------------------------------------------ |
| **方法定义**   | 访问修饰符、返回值类型、方法名、参数列表、方法体（语句块）。 |
| **调用方式**   | 静态方法（`类名.方法名`）、实例方法（`对象.方法名`）。       |
| **方法重载**   | 同一类中，方法名相同，参数列表不同（个数、类型、顺序）。     |
| **递归**       | 方法调用自身，必须有终止条件，避免栈溢出，适用于分治问题。   |
| **值传递**     | 基本类型传值副本，引用类型传引用副本，修改形参不影响实参（内容除外）。 |

掌握以上知识点后，可以灵活定义和调用方法，轻松实现代码复用与模块化编程。