第一步 创建文章类型模型，同步生成数据表

首先创建文章类型的模型表：

```js
const { DataTypes } = require("sequelize");
const sequelize = require("../dbConnect");

// 定义数据模型
module.exports = sequelize.define("blogType", {
    // 这张表拥有哪些字段
    name : {
        type : DataTypes.STRING,
        allowNull : false
    },
    articleCount : {
        type : DataTypes.INTEGER,
        allowNull : false
    },
    order : {
        type : DataTypes.INTEGER,
        allowNull : false
    },
},{
    freezeTableName : true,
    createdAt : false,
    updatedAt : false
});

```

在 `db.js` 中导入即可进行模型同步

```js
const blogTypeModel = require("./model/bannerModel");
```

第二步 梳理文章类型模块逻辑，编写路由层和逻辑层以及数据层的粗略框架

首先创建文件

- 在 `/routes`目录下 创建 `blogTypeRouter.js`文件
- 在 `/service`目录下 创建 `blogTypeService.js`文件
- 在 `/dao/crud`目录下 创建 `blogTypeDao.js`文件

相关路由的功能及对应的服务层方法，数据从方法命名参考

| 路径                 | 方法   | 说明             | 对应的服务层方法         | 对应的数据层方法     |
| -------------------- | ------ | ---------------- | ------------------------ | -------------------- |
| `/api/blogtype`      | POST   | 添加文章分类     | `addBlogTypeService`     | `addBlogTypeDao`     |
| `/api/blogtype`      | GET    | 获取所有文章分类 | `findAllBlogTypeService` | `findAllBlogTypeDao` |
| `/api/blogtype/{id}` | DELETE | 删除文章分类     | `deleteBlogTypeService`  | `.deleteBlogTypeDao` |
| `/api/blogtype/{id}` | PUT    | 修改文章分类     | `updateBlogTypeService`  | `updateBlogTypeDao`  |
| `/api/blogtype/{id}` | GET    | 获取一个分类     | `findOneBlogTypeService` | `findOneBlogTypeDao` |

第三步 实现添加文章分类，梳理完单个例子的逻辑

- 需要使用到`validate.js`验证库，定义验证规则来保证添加到数据库的数据符合规范

```bash
$ npm i validate.js
```

添加文章的路由层：

```js
router.post("/", async (req, res, next) => {
  res.send(await addBlogTypeService(req.body));
});
```

添加文章分类服务层：

```js
module.exports.addBlogTypeService = async (newBlogTypeInfo) => {
  // 定义验证规则
  const validateRule = {
    name: {
      presence: {
        allowEmpty: false,
        message: "文章分类名不能为空",
      },
      type: "string",
    },
    order: {
      presence: {
        allowEmpty: false,
        message: "文章分类级别不能为空",
      },
      type: "integer",
    },
  };
  if (!validate.validate(newBlogTypeInfo, validateRule)) {
    // 数据验证成功，符合要求
    newBlogTypeInfo.articleCount = 0; // 因为是新增的文章分类，所以一开始文章数量为 0
    return formatResponse(0, "", await addBlogTypeDao(newBlogTypeInfo));
  } else {
    throw new ValidateError("数据验证失败");
  }
};
```

添加文章的数据层

```js
module.exports.addBlogTypeDao = async (newBlogTypeInfo) => {
  const { dataValues } = await blogTypeModel.create(newBlogTypeInfo);
  return dataValues;
};
```

第四步 完成实现其他逻辑

完整路由层：

```js
const express = require("express");
const router = express.Router();
const {
  addBlogTypeService,
  findAllBlogTypeService,
  findOneBlogTypeService,
  updateBlogTypeService,
  deleteBlogTypeService,
} = require("../service/blogTypeService");
// 添加文章分类
router.post("/", async (req, res, next) => {
  res.send(await addBlogTypeService(req.body));
});

// 获取所有文章分类
router.get("/", async (req, res, next) => {
  res.send(await findAllBlogTypeService());
});

// 获取单个文章分类
router.get("/:id", async (req, res, next) => {
  res.send(await findOneBlogTypeService(req.params.id));
});

// 修改单个文章分类
router.put("/:id", async (req, res, next) => {
  res.send(await updateBlogTypeService(req.params.id, req.body));
});

// 删除单个文章分类
router.delete("/:id", async (req, res, next) => {
  res.send(await deleteBlogTypeService(req.params.id));
});

module.exports = router;
```

完整服务层

```js
const validate = require("validate.js");
const {
  addBlogTypeDao,
  findAllBlogTypeDao,
  findOneBlogTypeDao,
  updateBlogTypeDao,
  deleteBlogTypeDao,
} = require("../dao/crud/blogTypeDao");
const { formatResponse, handleArryData } = require("../utils/tool");
const { ValidateError } = require("../utils/errors");

// 添加文章分类
module.exports.addBlogTypeService = async (newBlogTypeInfo) => {
  // 定义验证规则
  const validateRule = {
    name: {
      presence: {
        allowEmpty: false,
        message: "文章分类名不能为空",
      },
      type: "string",
    },
    order: {
      presence: {
        allowEmpty: false,
        message: "文章分类级别不能为空",
      },
      type: "string",
    },
  };
  if (!validate.validate(newBlogTypeInfo, validateRule)) {
    // 数据验证成功，符合要求
    newBlogTypeInfo.articleCount = 0; // 因为是新增的文章分类，所以一开始文章数量为 0
    return formatResponse(0, "", await addBlogTypeDao(newBlogTypeInfo));
  } else {
    throw new ValidateError("数据验证失败");
  }
};

// 获取所有文章分类
module.exports.findAllBlogTypeService = async () => {
  const data = handleArryData(await findAllBlogTypeDao());
  return formatResponse(
    0,
    "",
    data.sort((a, b) => a.order - b.order)
  );
};

// 获取单个文章分类
module.exports.findOneBlogTypeService = async (id) => {
  return formatResponse(0, "", await findOneBlogTypeDao(id));
};

// 修改文章分类
module.exports.updateBlogTypeService = async (id, updatedBlogTypeInfo) => {
  return formatResponse(
    0,
    "",
    await updateBlogTypeDao(id, updatedBlogTypeInfo)
  );
};

// 删除文章分类
module.exports.deleteBlogTypeService = async (id) => {
  await deleteBlogTypeDao(id);
  return formatResponse(0, "", true);
};
```

完整数据层

```js
const blogTypeModel = require("../model/blogTypeModel");

// 添加文章分类
module.exports.addBlogTypeDao = async (newBlogTypeInfo) => {
  const { dataValues } = await blogTypeModel.create(newBlogTypeInfo);
  return dataValues;
};

// 获取所有文章分类
module.exports.findAllBlogTypeDao = async () => {
  return await blogTypeModel.findAll();
};

// 获取单个文章分类
module.exports.findOneBlogTypeDao = async (id) => {
  const { dataValues } = await blogTypeModel.findByPk(id);
  return dataValues;
};

// 修改文章分类
module.exports.updateBlogTypeDao = async (id, updatedBlogTypeInfo) => {
  await blogTypeModel.update(updatedBlogTypeInfo, {
    where: {
      id,
    },
  });
  const { dataValues } = await blogTypeModel.findByPk(id);
  return dataValues;
};

// 删除文章分类
module.exports.deleteBlogTypeDao = async (id) => {
  return blogTypeModel.destroy({
    where: { id },
    force: true, // 强制删除
  });
};
```

