# 源代码

第一步 创建文章模型，同步生成数据表，关联文章类型模型

创建文章表：

```js
const { DataTypes } = require("sequelize");
const sequelize = require("../dbConnect");

// 定义数据模型
module.exports = sequelize.define(
  "blog",
  {
    // 这张表拥有哪些字段
    title: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    toc: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    htmlContent: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    thumb: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    scanNumber: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    commentNumber: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    createDate: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  }
);

```

进行关联定义，修正原先的数据同步，避免重复创建外键

```js
// 导入连接实例、模型实例及其他第三方库
const sequelize = require("./dbConnect");
const adminModel = require("./model/adminModel");
const bannerModel = require("./model/bannerModel");
const blogTypeModel = require("./model/blogTypeModel");
const blogModel = require("./model/blogModel");
const md5 = require("md5");

// 定义模型关联关系函数
const defineAssociations = () => {
  blogTypeModel.hasMany(blogModel, {
    foreignKey: "categoryId",
    targetKey: "id",
  });

  blogModel.belongsTo(blogTypeModel, {
    foreignKey: "categoryId",
    targetKey: "id",
    as: "category",
  });
};

(async function () {
  // 步骤1: 定义关联关系
  defineAssociations();
  const queryInterface = sequelize.getQueryInterface();

  // 步骤2: 条件数据库同步
  if (process.env.NODE_ENV === "development") {
    // 开发环境: 只同步一次
    const tableExists = await sequelize.getQueryInterface().showAllTables();
    if (tableExists.length === 0) {
      await sequelize.sync();
      console.log("数据库表结构已创建");
    }
  } else {
    // 生产环境: 使用迁移工具
    console.log("生产环境请使用迁移工具");
  }

  // 步骤3: 初始化数据（保持不变）
  const adminCount = await adminModel.count();
  if (!adminCount) {
    await adminModel.create({
      loginId: "admin",
      name: "超级管理员",
      loginPwd: md5("123456"),
    });
    console.log("初始化管理员数据完毕...");
  }

  const bannerCount = await bannerModel.count();
  if (!bannerCount) {
    await bannerModel.bulkCreate([
      {
        midImg: "/static/images/bg1_mid.jpg",
        bigImg: "/static/images/bg1_big.jpg",
        title: "塞尔达旷野之息",
        description: "2017年年度游戏，期待续作",
      },
      {
        midImg: "/static/images/bg2_mid.jpg",
        bigImg: "/static/images/bg2_big.jpg",
        title: "塞尔达四英杰",
        description: "四英杰里面你最喜欢的又是谁呢",
      },
      {
        midImg: "/static/images/bg3_mid.jpg",
        bigImg: "/static/images/bg3_big.jpeg",
        title: "日本街道",
        description: "动漫中经常出现的日本农村街道，一份独特的恬静",
      },
    ]);
    console.log("初始化首页标语数据...");
  }

  console.log("数据库准备完成");
})();
```

第二部 理顺路由逻辑 调整目录结构

| 路径             | 方法   | 说明                  | 对应的服务层方法     | 对应的数据层方法 |
| ---------------- | ------ | --------------------- | -------------------- | ---------------- |
| `/api/blog`      | POST   | 添加一篇文章          | `addBlogService`     | `addBlogDao`     |
| `/api/blog`      | GET    | 分页获取/获取所有文章 | `findAllBlogService` | `findAllBlogDao` |
| `/api/blog/{id}` | DELETE | 删除一篇文章          | `deleteBlogService`  | `.deleteBlogDao` |
| `/api/blog/{id}` | PUT    | 修改一篇文章          | `updateBlogService`  | `updateBlogDao`  |
| `/api/blog/{id}` | GET    | 获取一篇文章          | `findOneBlogService` | `findOneBlogDao` |

第三步 完成各个路由逻辑

路由层：

```js
var express = require("express");
const {
  addBlogService,
  findBlogByPageService,
  findBlogByIdService,
  updateBlogService,
  deleteBlogService,
} = require("../service/blogService");
var router = express.Router();

// 添加博客
router.post("/", async function (req, res, next) {
  res.send(await addBlogService(req.body));
});

// 分页获取博客
router.get("/", async function (req, res, next) {
  res.send(await findBlogByPageService(req.query));
});

// 获取其中一个博客
router.get("/:id", async function (req, res, next) {
  const reqHeaders = req.headers;
  res.send(await findBlogByIdService(req.params.id, reqHeaders.authorization));
});

// 修改其中一个博客
router.put("/:id", async function (req, res, next) {
  res.send(await updateBlogService(req.params.id, req.body));
});

// 删除其中一个博客
router.delete("/:id", async function (req, res, next) {
  res.send(await deleteBlogService(req.params.id));
});

module.exports = router;
```

服务层：

```js
const { validate } = require("validate.js");
const { addBlogDao, findBlogByPageDao, findBlogByIdDao, updateBlogDao, deleteBlogDao } = require("../dao/blogDao");
const { addBlogToType, findOneBlogTypeDao } = require("../dao/blogTypeDao");
const blogTypeModel = require("../dao/model/blogTypeModel");
const { ValidationError } = require("../utils/errors");
const { formatResponse, handleDataPattern } = require("../utils/tool");

// 扩展验证规则
validate.validators.categoryIdIsExist = async function (value) {
    const blogTypeInfo = blogTypeModel.findByPk(value);
    if (blogTypeInfo) {
        return;
    }
    return "CategoryId Is Not Exist";
}

// 添加博客
module.exports.addBlogService = async function (newBlogInfo) {

    // 首先第一个要处理的就是 TOC
    // 这个我们放在下一节课

    // 接下来，我们将处理好的TOC格式转为字符串
    newBlogInfo.toc = JSON.stringify('["a":"b"]');

    // 初始化新文章的其他信息
    newBlogInfo.scanNumber = 0; // 阅读量初始化为 0
    newBlogInfo.commentNumber = 0; // 评论数初始化为 0 

    // 定义验证规则
    const blogRule = {
        title: {
            presence: {
                allowEmpty: false
            },
            type: "string"
        },
        description: {
            presence: {
                allowEmpty: true
            },
            type: "string"
        },
        toc: {
            presence: {
                allowEmpty: true
            },
            type: "string"
        },
        htmlContent: {
            presence: {
                allowEmpty: false
            },
            type: "string"
        },
        thumb: {
            presence: {
                allowEmpty: true
            },
            type: "string"
        },
        scanNumber: {
            presence: {
                allowEmpty: false
            },
            type: "integer"
        },
        commentNumber: {
            presence: {
                allowEmpty: false
            },
            type: "integer"
        },
        createDate: {
            presence: {
                allowEmpty: false
            },
            type: "integer"
        },
        categoryId: {
            presence: true,
            type: "integer",
            categoryIdIsExist: true
        }
    }

    // 接下来对传递过来的数据进行一个验证
    try {
        // 因为扩展的验证规则里面涉及到异步的操作，所以这里要采用异步的验证方式
        await validate.async(newBlogInfo, blogRule);
        const data = await addBlogDao(newBlogInfo); // 进行一个新增
        // 接下来还有一个工作，文章新增了，对应的文章分类也应该新增
        await addBlogToType(newBlogInfo.categoryId);
        return formatResponse(0, "", data);
    } catch (e) {
        // 验证未通过
        throw new ValidationError("数据验证失败");
    }
}

// 根据分页来查询博客
module.exports.findBlogByPageService = async function (pageInfo) {
    const data = await findBlogByPageDao(pageInfo);
    const rows = handleDataPattern(data.rows);
    // 针对 TOC 要做一个还原的操作
    rows.forEach(it => {
        it.toc = JSON.parse(it.toc);
    });
    return formatResponse(0, "", {
        "total": data.count,
        "rows": rows
    })
}

// 根据 id 获取某一篇博文
module.exports.findBlogByIdService = async function (id, auth) {
    const data = await findBlogByIdDao(id);
    // 首先需要重新处理 TOC，还原成一个数组
    data.dataValues.toc = JSON.parse(data.dataValues.toc);
    // 根据 auth 是否有值来决定浏览数是否要自增
    if (!auth) {
        data.scanNumber++;
        await data.save();
    }
    return formatResponse(0, "", data.dataValues);
}

// 修改一篇博文
module.exports.updateBlogService = async function (id, newBlogInfo) {
    // 首先判断正文内容有没有改变，因为正文内容的改变会影响 TOC
    if (newBlogInfo.htmlContent) {
        // 进入此 if，说明文章的正文内容有所改变，需要重新处理 TOC 目录

        newBlogInfo.toc = JSON.stringify('["a":"b"]');
    }
    const { dataValues } = await updateBlogDao(id, newBlogInfo);
    return formatResponse(0, "", dataValues);
}

// 删除一篇博文
module.exports.deleteBlogService = async function(id){
    // 根据 id 查询到该篇文章的信息
    const data = await findBlogByIdDao(id);
    // 接下来需要根据该文章对应的分类，该分类下的文章数量自减
    const categoryInfo = await findOneBlogTypeDao(data.dataValues.categoryId);
    categoryInfo.articleCount--;
    await categoryInfo.save();
    // 之后还有一个操作，就是该文章下所对应的评论也要一并删除

    // 之后就可以删除这篇文章了
    await deleteBlogDao(id);
    return formatResponse(0, "", true);
}
```

数据访问层：

```js
const blogModel = require("./model/blogModel");
const blogTypeModel = require("./model/blogTypeModel");

// 添加博客
module.exports.addBlogDao = async function (newBlogInfo) {
    const { dataValues } = await blogModel.create(newBlogInfo);
    return dataValues;
}

// 根据分页信息来查询博客
module.exports.findBlogByPageDao = async function(pageInfo){
    // { page: '1', limit: '5', categoryid: '2' }
    if(pageInfo.categoryid && pageInfo.categoryid !== '-1'){
        // 根据分类信息来进行分页查询
        return await blogModel.findAndCountAll({
            include : [
                {
                    model : blogTypeModel,
                    as : "category",
                    where : {
                        id : pageInfo.categoryid
                    }
                }
            ],
            offset : (pageInfo.page * 1 - 1) * pageInfo.limit,
            limit : pageInfo.limit * 1
        })
    } else {
        // 根据所有博客文章进行分页查询
        return await blogModel.findAndCountAll({
            include : [
                {
                    model : blogTypeModel,
                    as : "category"
                }
            ],
            offset : (pageInfo.page * 1 - 1) * pageInfo.limit,
            limit : pageInfo.limit * 1
        })
    }
}

// 根据 id 获取其中一篇文章
module.exports.findBlogByIdDao = async function(id){
    return await blogModel.findByPk(id, {
        include : [
            {
                model : blogTypeModel,
                as : "category"
            }
        ]
    })
}

// 修改一篇博文
module.exports.updateBlogDao = async function(id, newBlogInfo){
    await blogModel.update(newBlogInfo, {
        where : {
            id
        }
    });
    return await blogModel.findByPk(id);
}

// 删除一篇博客
module.exports.deleteBlogDao = async function(id){
    return await blogModel.destroy({
        where : {
            id
        }
    })
}

```

# 解析

## 理清客户端的请求：

客户端的请求需要通过接口文档来梳理清楚：

- 请求路径和方法是什么？这决定了前后端路由方法的编写、动态路由的传参等等。
- 请求头中那些参数是必须的？是否涉及到含身份验证token传递等等
- 请求体要求为什么格式？添加数据的请求要保证添加项目能与数据库的各个列名相对应

### 请求 URL:

`POST`http://localhost:7001/api/blog

### Header:

| 名称          | 值                |
| :------------ | :---------------- |
| Authorization | Bearer+空格+token |
| Content-Type  | application/json  |

### Body:

Body 类型 : application/json

```json
{
    "title": "我命律收面放总高空报象效每土子具华整指好",
    "description": "气则进群律活去史只查里律建方照应。天务长消总发热它采南质连所并。",
    "createDate": 1668301536074,
    "scanNumber": 6011,
    "commentNumber": 23,
    "categoryId": 9,
    "toc": "[{\"name\":\"斯称验型光\",\"anchor\":\"fykffn\",\"children\":[{\"name\":\"起其便八色加走\",\"anchor\":\"hpdgv\"},{\"name\":\"标东属必结\",\"anchor\":\"vpkzebr\"}]}]",
    "htmlContent": "<!DOCTYPEhtml><htmllang=\"en\"><head><metacharset=\"UTF-8\"><metaname=\"viewport\"content=\"width=device-width,initial-scale=1.0\"><title>Document</title></head><body>政准格看包多区外产率不子日建。省变点业八土手其天记般情指十队群。传律标段山类管但何变育千场影立。改极出相说联少以电其的就拉论五。特程识思式严术反目化开长省本参四于局。领头群精严然京县劳下量安小需速化华。实多备量安该被置好照化无研思他。华术南它七流众委气安便价主连。至广广位照革地是深保之传。起前少位代南系为问他格清下都提据红已。安起此极法情影口连因但速声办。及成将物律置儿难积采接生土便开备选。月活展半展听然水造元日水不内新文。参周元团样林见指直气解平场手题。青示子往别极区正派几县商学原往。包除音解院认问型界先铁步确元备问。</body></html>",
    "thumb": "http://dummyimage.com/200x200/50B347/FFF&text=缩略图"
}
```

这里请求头必须包含Content-Type和Authorization。

这里使用了mockjs对请求体的数据进行了模拟生成:

```js
const Mock = require("mockjs");

const data = Mock.mock({
  title: "@ctitle(10, 30)", // 10-30字中文标题
  description: "@cparagraph(1, 3)", // 1-3句中文描述
  createDate: "@integer(1609459200000, 1672531199000)", // 2021-2023年的时间戳
  scanNumber: "@integer(100, 10000)", // 100-10000的浏览量
  commentNumber: "@integer(0, 500)", // 0-500的评论数
  categoryId: "@integer(1, 5)",
  "toc|1-3": [
    {
      // 生成1-3个目录项
      name: "@ctitle(4, 8)", // 目录名称
      anchor: "@word(3, 10)", // 锚点ID
      "children|0-3": [
        {
          // 生成0-3个子目录
          name: "@ctitle(4, 8)",
          anchor: "@word(3, 10)",
        },
      ],
    },
  ],
  htmlContent: `<!DOCTYPEhtml><htmllang="en"><head><metacharset="UTF-8"><metaname="viewport"content="width=device-width,initial-scale=1.0"><title>Document</title></head><body>${Mock.mock(
    "@cparagraph(10, 20)"
  )}</body></html>`, // 10-20段HTML内容
  thumb: "@image('200x200', '#50B347', '#FFF', '缩略图')", // 图片URL
});
// 将生成的数组格式的目录转为为JSON字符串存储到数据库，符合数据库格式
data.toc = JSON.stringify(data.toc);
console.log(JSON.stringify(data, null, 2));
```

