在 `validate.js` 中，通过声明式 JSON 对象配置字段规则。以下是核心配置指南，涵盖常用验证器及其使用场景：

---

### 一、**规则配置基础结构**
```javascript
const rules = {
  字段名: {
    验证器1: 配置选项,
    验证器2: 配置选项,
    // ...
  }
};
```

---

### 二、**常用内置验证器配置**

#### 1. **存在性校验** (`presence`)
```javascript
username: {
  presence: {
    allowEmpty: false, // 禁止空字符串（默认 true）
    message: "^用户名不能为空" // 自定义错误提示
  }
}
```

#### 2. **数据类型校验** (`type`)
```javascript
age: {
  type: "integer", // 整数
  numericality: {   // 数值范围
    greaterThan: 0,
    lessThanOrEqualTo: 120
  }
}
```
支持类型：`string | boolean | integer | number | array | object | date`

#### 3. **长度校验** (`length`)
```javascript
password: {
  length: {
    minimum: 8,     // 最小长度
    maximum: 20,    // 最大长度
    tooShort: "至少需要 %{count} 位字符",
    tooLong: "不能超过 %{count} 位字符"
  }
}
```

#### 4. **格式校验** (`format`)
```javascript
email: {
  format: {
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, // 邮箱正则
    message: "无效的邮箱格式"
  }
}
```

#### 5. **枚举校验** (`inclusion`)
```javascript
role: {
  inclusion: {
    within: ["admin", "editor", "user"], // 允许值
    message: "无效的用户角色"
  }
}
```

#### 6. **相等性校验** (`equality`)
```javascript
passwordConfirm: {
  equality: {
    attribute: "password", // 需匹配的字段名
    message: "两次密码不一致"
  }
}
```

#### 7. **日期校验** (`datetime`)
```javascript
birthday: {
  datetime: {
    dateOnly: true, // 仅日期（不含时间）
    earliest: new Date(1900, 0, 1), // 最早日期
    latest: new Date() // 最晚日期（今天）
  }
}
```

---

### 三、**高级配置技巧**

#### 1. **条件校验**
```javascript
paymentMethod: {
  presence: true,
  inclusion: { within: ["credit", "paypal"] }
},
creditCard: {
  presence: {
    message: "需要信用卡信息",
    if: (value, attributes) => attributes.paymentMethod === "credit"
  },
  format: { pattern: /^\d{16}$/ }
}
```

#### 2. **嵌套对象校验**
```javascript
user: {
  type: "object",
  presence: true,
  object: {
    name: { presence: true },
    address: {
      type: "object",
      street: { presence: true },
      city: { presence: true }
    }
  }
}
```

#### 3. **数组校验**
```javascript
tags: {
  type: "array",
  length: { minimum: 1, maximum: 5 },
  array: {
    inclusion: { within: ["js", "css", "html"] }
  }
}
```

---

### 四、**自定义验证器示例**
```javascript
// 注册自定义验证器
validate.validators.phone = function(value) {
  if (!value) return null; // 允许空值
  return /^1[3-9]\d{9}$/.test(value) ? null : "无效的手机号";
};

// 使用自定义验证器
const rules = {
  mobile: {
    phone: true // 启用自定义验证
  }
};
```

---

### 五、**完整配置示例**
```javascript
const userRules = {
  username: {
    presence: { allowEmpty: false },
    length: { minimum: 4, maximum: 16 },
    format: { pattern: /^[a-z0-9_]+$/i }
  },
  email: {
    presence: true,
    email: true
  },
  age: {
    numericality: {
      onlyInteger: true,
      greaterThan: 13
    }
  },
  interests: {
    type: "array",
    length: { maximum: 3 }
  },
  profile: {
    type: "object",
    object: {
      bio: {
        type: "string",
        length: { maximum: 200 }
      }
    }
  }
};

// 执行验证
const errors = validate(userData, userRules);
```

---

### 六、**最佳实践建议**
1. **分层验证**：对复杂对象拆分多级规则
2. **复用规则**：共享基础规则（如 `baseUserRules`）
3. **动态规则**：根据业务状态生成规则
   ```javascript
   const getRules = (isAdmin) => ({
     accessLevel: {
       inclusion: { within: isAdmin ? [1,2,3] : [1] }
     }
   });
   ```
4. **错误消息定制**：
   ```javascript
   validate.validators.presence.message = "不能为空";
   ```

> 📘 官方文档参考：[validate.js Constraints](https://validatejs.org/#validators)  
> 建议结合业务需求选择验证器组合，优先使用内置验证器保证性能。