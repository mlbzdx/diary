上传图片需要使用到第三方库：multer

> 中文文档：https://github.com/expressjs/multer/blob/main/doc/README-zh-cn.md

安装第三方库：

```bash
$ npm install --save multernpm install --save multer
```

第一步：编写上传路由中间件，在入口文件注册该中间件

> ./routes/uploadRouter

```js
var express = require("express");
var router = express.Router();
router.post("/", async (req, res, next) => {
 
});
module.exports = router; 
```

> ./app.js

```js
var uploadRouter = require("./routes/uploadRouter");
//...
app.use("/api/upload", uploadRouter);
```

第二步：编写上传文件工具函数 

> /utils/tool.js

```js
// 设置上传文件的引擎
const storage = multer.diskStorage({
    // 文件存储的位置
    destination: function (req, file, cb) {
        cb(null, __dirname + '/../public/static/uploads');
    },
    // 上传到服务器的文件，文件名要做单独处理
    filename: function (req, file, cb) {
        // 获取文件名
        const basename = path.basename(file.originalname, path.extname(file.originalname));
        // 获取后缀名
        const extname = path.extname(file.originalname);
        // 构建新的名字
        const newName = basename + new Date().getTime() + Math.floor(Math.random() * 9000 + 1000) + extname;
        cb(null, newName);
    }
})

module.exports.uploading = multer({
    storage: storage,
    limits: {
        fileSize: 2000000,
        files: 1
    }
})
```

---

第三步：完善上传路由逻辑，自定义上传错误处理机制

> 上传图片的接口文档：
>
> 请求路径：/api/upload
>
> 请求方法：POST
>
> 请求配置：
>
> | header参数    | 示例值               |
> | ------------- | -------------------- |
> | Content-Type  | multipart/form-data  |
> | Authorization | Bearer + 空格 +token |
>
> 
>
> | body参数 | 格式：multipart/form-data |
> | -------- | ------------------------- |
> | file     | 要上传的文件，必须是图片  |
>
> 返回响应：
>
> HTTP 状态码: 200
>
> 内容格式: JSONapplication/json
>
> 数据结构：
>
> ```json
> {
>  "code": 0,
>  "msg": "string",
>  "data": "string"
> }
> ```

```js
var express = require("express");
const multer = require("multer");
const { UploadError } = require("../utils/errors");
const { uploading, formatResponse } = require("../utils/tool");
var router = express.Router();

// 获取首页标语
router.post("/", async function (req, res, next) {
    // single 方法里面书写上传控件的 name 值
    uploading.single("file")(req, res, function (err) {
        if(err instanceof multer.MulterError){
            next(new UploadError("上传文件失败，请检查文件的大小，控制在 2MB 以内"));
        } else {
            const path = "/static/uploads/" + req.file.filename;
            res.send(formatResponse(0, "", path));
        }
    })
});

module.exports = router;
```

> ## 错误处理机制
>
> 
>
> 当遇到一个错误，multer 将会把错误发送给 express。你可以使用一个比较好的错误展示页 ([express标准方式](http://expressjs.com/guide/error-handling.html))。
>
> 如果你想捕捉 multer 发出的错误，你可以自己调用中间件程序。如果你想捕捉 [Multer 错误](https://github.com/expressjs/multer/blob/main/lib/multer-error.js)，你可以使用 `multer` 对象下的 `MulterError` 类 (即 `err instanceof multer.MulterError`)。
>
> ```
> const multer = require('multer')
> const upload = multer().single('avatar')
> 
> app.post('/profile', function (req, res) {
> upload(req, res, function (err) {
>  if (err instanceof multer.MulterError) {
>    // 发生错误
>  } else if (err) {
>    // 发生错误
>  }
> 
>  // 一切都好
> })
> })
> ```







## 源代码：

```js
// 设置上传文件的引擎
const storage = multer.diskStorage({
    // 文件存储的位置
    destination: function (req, file, cb) {
        cb(null, __dirname + '/../public/static/uploads');
    },
    // 上传到服务器的文件，文件名要做单独处理
    filename: function (req, file, cb) {
        // 获取文件名
        const basename = path.basename(file.originalname, path.extname(file.originalname));
        // 获取后缀名
        const extname = path.extname(file.originalname);
        // 构建新的名字
        const newName = basename + new Date().getTime() + Math.floor(Math.random() * 9000 + 1000) + extname;
        cb(null, newName);
    }
})

module.exports.uploading = multer({
    storage: storage,
    limits: {
        fileSize: 2000000,
        files: 1
    }
})
```

## 文件存储位置解析

这段代码是 Multer 磁盘存储配置中的 `destination` 方法，用于**指定文件上传后存储的目标目录**。下面是详细解析：

```javascript
destination: function (req, file, cb) {
    cb(null, __dirname + '/../public/static/uploads');
}
```

---

### 1. 功能作用

- **核心功能**：定义上传文件的存储位置
- **执行时机**：在文件保存到服务器之前调用
- **工作流程**：当用户上传文件时，Multer 会调用此函数获取存储路径

---

### 2. 代码分解

#### a. `__dirname` 变量

- **含义**：Node.js 内置变量，表示**当前执行脚本所在的目录绝对路径**

- **示例**：如果代码文件位于 `/app/services/upload.js`

  ```javascript
  console.log(__dirname); 
  // 输出：/app/services
  ```

#### b. 路径拼接 `__dirname + '/../public/static/uploads'`

- **`/../`**：返回上一级目录（类似命令行中的 `cd ..`）

- **完整路径解析**：

  ```
  当前文件路径： /app/services/upload.js
  目标路径： __dirname + '/../public/static/uploads'
  计算过程：
    /app/services + /.. = /app
    /app + /public/static/uploads = /app/public/static/uploads
  ```

- **最终路径**：项目根目录下的 `public/static/uploads` 文件夹

#### c. 回调函数 `cb(null, path)`

- **参数1**：`null` 表示没有错误
- **参数2**：存储目录的**绝对路径**
- **作用**：将计算出的路径传递给 Multer

---

### 3. 目录结构示例

假设项目结构如下：

```
项目根目录/
├── app/
│   └── services/
│       └── upload.js   # 包含此代码的文件
├── public/
│   └── static/
│       └── uploads/    # 文件实际存储位置
└── package.json
```

上传的文件最终会保存在 `/项目根目录/public/static/uploads/filename.ext`

---

### 4. 关键注意事项

#### a. 目录必须存在！

Multer **不会自动创建目录**，如果目标文件夹不存在会导致报错。解决方案：

```javascript
const fs = require('fs');
const path = require('path');

destination: function (req, file, cb) {
  const uploadPath = path.join(__dirname, '../public/static/uploads');
  
  // 确保目录存在（递归创建）
  if (!fs.existsSync(uploadPath)) {
    fs.mkdirSync(uploadPath, { recursive: true });
  }
  
  cb(null, uploadPath);
}
```

#### b. 路径分隔符兼容性问题

- **问题**：`__dirname + '/../path'` 在 Windows 可能产生混合分隔符（`\` 和 `/`）
- **推荐改进**：使用 `path.join()` 保证跨平台兼容性

```javascript
const fullPath = path.join(__dirname, '..', 'public', 'static', 'uploads');
```

#### c. 静态资源访问

此配置将文件保存在 `public` 目录下，意味着：

```javascript
// 可直接通过URL访问
http://yourdomain.com/static/uploads/filename.jpg

// 需要配置Express静态资源中间件
app.use('/static', express.static(path.join(__dirname, 'public', 'static')));
```

---

### 5. 安全考量

1. **不要暴露敏感路径**：

   - 避免使用用户输入动态生成路径（防路径遍历攻击）

   ```javascript
   // ❌ 危险示例（可能泄漏系统文件）
   destination: (req, file, cb) => {
     cb(null, `/uploads/${req.params.userId}`); 
   }
   ```

2. **设置访问权限**：

   ```javascript
   // 创建目录时设置权限（Linux/Mac）
   fs.mkdirSync(uploadPath, {
     recursive: true,
     mode: 0o755 // 用户rwx，组/其他r-x
   });
   ```

---

### 6. 完整最佳实践示例

```javascript
const path = require('path');
const fs = require('fs');
const multer = require('multer');

// 安全获取上传路径
const getUploadPath = () => {
  const uploadDir = path.join(__dirname, '..', 'public', 'static', 'uploads');
  
  // 确保目录存在
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { 
      recursive: true,
      mode: 0o755  // 设置权限
    });
  }
  
  return uploadDir;
};

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, getUploadPath());
  },
  filename: (req, file, cb) => {
    /* 文件名生成逻辑 */
  }
});

const upload = multer({ storage });
```

这种配置方式适合存储需要公开访问的静态资源（如图片、文档等），如果是敏感文件建议存储在 `public` 目录之外并通过后端路由控制访问。

## 文件名称位置解析

```javascript
filename: function (req, file, cb) {
  // 1. 获取文件基本名（不含扩展名）
  const basename = path.basename(
    file.originalname,                 // 原始文件名（含扩展名）
    path.extname(file.originalname)    // 提取扩展名用作第二个参数
  );
  
  // 2. 获取文件扩展名（包含点符号）
  const extname = path.extname(file.originalname); // 如 ".jpg"
  
  // 3. 构建唯一的新文件名：
  const newName = basename +           // 原始文件名（不含扩展名）
    new Date().getTime() +             // 当前时间戳（毫秒）
    Math.floor(Math.random() * 9000 + 1000) + // 生成1000-9999的随机数
    extname;                           // 原始扩展名
  
  // 4. 回调返回新文件名
  cb(null, newName);
}
```

---

### 关键组件详解：

#### 1. `path.basename()` 方法

- **作用**：获取不含路径的文件名  
- **参数**：  
  - `file.originalname`：原始文件名（如 `"风景照.jpg"`）
  - `path.extname(...)`：文件扩展名（如 `".jpg"`）
- **结果**：返回去掉扩展名的文件名（如 `"风景照"`）

#### 2. `path.extname()` 方法

- **作用**：获取文件的扩展名（含点符号）
- **示例**：  
  `file.originalname = "document.pdf"` → 返回 `".pdf"`

#### 3. 唯一文件名构造逻辑：

| 组成部分               | 示例值          | 作用                 |
| ---------------------- | --------------- | -------------------- |
| `basename`             | `"报告"`        | 保留原始文件标识     |
| `new Date().getTime()` | `1717840000000` | 保证时间维度唯一性   |
| `Math.floor(...)`      | `4512`          | 防止同一毫秒内的冲突 |
| `extname`              | `".docx"`       | 保持原始文件类型     |

#### 4. 随机数生成原理：

```javascript
Math.floor(Math.random() * 9000 + 1000)
```

- `Math.random()`：生成 [0,1) 的随机数
- `* 9000`：扩展到 [0,9000)
- `+ 1000`：平移范围到 [1000,10000)
- `Math.floor()`：取整 → 得到 **1000-9999** 的整数

---

### 文件名示例：

假设上传文件 `数据.csv`：

```javascript
原始文件名： "数据.csv"
basename:   "数据"
extname:    ".csv"
时间戳：     1717840123456
随机数：     7328

生成的新文件名 → "数据17178401234567328.csv"
```

---

### 为什么要这样设计？

1. **避免覆盖冲突**  
   - 多人同时上传同名文件时  
   - 同一用户多次上传同名文件时

2. **保留原始文件信息**  
   - `basename` 维持文件名可读性  
   - `extname` 保持文件类型识别

3. **高并发下的唯一性保证**  
   - **时间戳**：解决跨时段冲突  
   - **随机数**：解决毫秒级并发冲突

---

### 潜在改进建议：

```javascript
// 建议改进版本（更简短高效）：
filename: (req, file, cb) => {
  const ext = path.extname(file.originalname);
  const name = path.basename(file.originalname, ext);
  
  cb(null, `${name}-${Date.now()}-${Math.random().toString(36).slice(2, 6)}${ext}`);
}
// 生成示例: "数据-1717840123456-4df9.csv"
```

#### 改进点：

1. 使用模板字符串提高可读性
2. `Math.random().toString(36)` 生成更短的随机字符串（字母+数字）
3. 添加连字符 `-` 分隔各部分，提高可读性

---

### 重要注意事项：

1. **中文文件名问题**  
   如果原始含中文名可能出现乱码，需添加转码：

   ```javascript
   const decodedName = Buffer.from(file.originalname, 'latin1').toString('utf8');
   ```

2. **特殊字符过滤**  
   防止文件名包含非法字符：

   ```javascript
   const safeName = name.replace(/[<>:"/\\|?*]/g, '_');
   ```

3. **长度控制**  
   建议添加文件名长度限制：

   ```javascript
   const shortName = name.substring(0, 50); // 保留前50字符
   ```

改进后的代码：

```js
filename: function (req, file, cb) {
  // 1. 处理中文文件名乱码问题（浏览器通常使用latin1编码传递文件名）
  const decodedName = Buffer.from(file.originalname, 'latin1').toString('utf8');
  
  // 2. 获取文件基本名和扩展名
  const ext = path.extname(decodedName);           // 包含点的扩展名 (.jpg)
  const basename = path.basename(decodedName, ext); // 不含扩展名的文件名
  
  // 3. 过滤非法字符（替换为下划线）
  const safeBasename = basename.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_');
  
  // 4. 限制文件名长度（最多50个字符）
  const truncatedName = safeBasename.substring(0, 50);
  
  // 5. 生成唯一文件名（优化版）
  const newName = `${truncatedName}-${Date.now()}-${Math.random()
    .toString(36)      // 转换为36进制字符串（0-9a-z）
    .slice(2, 6)       // 取4位随机字符（更简洁）
  }${ext}`;
  
  cb(null, newName);
}
```























