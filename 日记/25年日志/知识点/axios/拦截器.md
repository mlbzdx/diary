# 请求拦截

在 Axios 的请求拦截器（`axios.interceptors.request.use`）中，可以注册两个回调函数，分别用于**请求发送前的配置处理**和**请求配置错误的捕获**。以下是详细解析：

---

## **1. 两个回调函数的作用与触发时机**
| 回调函数                       | 作用                                                 | 触发时机                                     |
| ------------------------------ | ---------------------------------------------------- | -------------------------------------------- |
| **第一个函数（处理请求配置）** | 在请求发送前对配置进行修改（如添加请求头、校验参数） | 请求即将发送且配置无错误时触发               |
| **第二个函数（处理配置错误）** | 捕获请求配置阶段的错误（如无效 URL、非法参数）       | 请求配置出错时触发（如 `config` 格式不正确） |

---

## **2. 回调函数的参数与属性**
两个回调函数的参数分别是**请求配置对象**和**错误对象**，它们的结构和用途如下：

### **（1）成功回调的参数：`config`**
成功回调的参数是 Axios 的请求配置对象，包含以下常用属性：

| 属性名            | 类型      | 描述                                                         |
| ----------------- | --------- | ------------------------------------------------------------ |
| `url`             | `string`  | 请求的 URL（支持相对路径或绝对路径）                         |
| `method`          | `string`  | HTTP 方法（如 `get`、`post`），默认为 `get`                  |
| `headers`         | `object`  | 自定义请求头（如 `{ 'Content-Type': 'application/json' }`）  |
| `params`          | `object`  | URL 查询参数（GET 请求使用），会自动序列化为查询字符串       |
| `data`            | `any`     | 请求体数据（POST/PUT 请求使用），支持对象、字符串、`FormData` 等 |
| `timeout`         | `number`  | 请求超时时间（单位：毫秒）                                   |
| `withCredentials` | `boolean` | 是否携带跨域凭据（如 cookies），默认为 `false`               |
| **自定义属性**    | `any`     | 可以添加自定义字段（如 `isLoading` 用于控制加载动画）        |

### **（2）错误回调的参数：`error`**
错误回调的参数是 Axios 封装的错误对象，包含以下常用属性：

| 属性名         | 类型      | 描述                                         |
| -------------- | --------- | -------------------------------------------- |
| `message`      | `string`  | 错误描述信息（如 "Network Error"）           |
| `config`       | `object`  | 触发错误的原始请求配置                       |
| `isAxiosError` | `boolean` | 标识是否为 Axios 封装的错误（始终为 `true`） |

---

## **3. 实际应用示例**
### **（1）成功处理：添加 Token**
以下示例展示如何在请求头中统一添加认证 Token：
```javascript
axios.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token'); // 从本地存储中获取 Token
    if (token) {
      config.headers.Authorization = `Bearer ${token}`; // 在请求头中添加 Token
    }
    return config; // 必须返回修改后的配置对象
  }
);
```
**应用场景**：统一处理认证信息，避免在每个请求中重复编写代码。

---

### **（2）错误处理：捕获配置错误**
以下示例展示如何捕获请求配置中的错误并进行日志记录：
```javascript
axios.interceptors.request.use(
  null, // 跳过成功回调
  error => {
    console.error('请求配置错误:', error.message); // 打印错误信息
    return Promise.reject(error); // 终止请求链并将错误传递给后续处理
  }
);
```
**应用场景**：捕获无效配置（如未定义 `url` 或参数格式错误），避免请求发送失败后无提示。

---

## **4. 注意事项**
1. **配置修改需谨慎**  
   - 请求拦截器会对所有请求生效，直接修改 `config` 会影响全局配置。建议通过 `axios.create()` 创建独立实例以隔离配置。
   
2. **错误处理不可缺失**  
   - 如果未提供第二个回调函数（错误处理），配置阶段的错误可能被忽略，导致问题难以排查。

3. **自定义属性限制**  
   - 如果需要在 `config` 对象中添加自定义属性（如 `isLoading`），需确保这些字段在 Axios 的白名单中，否则会被过滤。

4. **必须返回 `config`**  
   - 在成功回调中，必须返回修改后的 `config` 对象，否则请求将无法发送。

---

## **总结**
通过请求拦截器，可以实现对请求配置的全局管理，例如动态添加认证信息、统一参数校验等。同时，合理处理配置阶段的错误，可以提高代码的健壮性和可维护性。更多详情可参考 [Axios 官方文档](https://www.axios-http.cn/docs/interceptors)。

# 响应拦截

在 Axios 的响应拦截器中，`axios.interceptors.response.use` 方法接收两个回调函数，分别用于处理**成功响应**和**错误响应**。以下是详细解析：

---

## **1. 两个回调函数的作用与触发时机**
| 回调函数                       | 作用                                                         | 触发时机                                                     |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **第一个函数（处理成功响应）** | 对 HTTP 状态码为 `2xx` 的响应进行预处理（如提取数据、格式化响应） | 当 HTTP 状态码为 `2xx`（如 200、201）时触发                  |
| **第二个函数（处理错误响应）** | 处理 HTTP 状态码超出 `2xx` 的响应（如 404、500）或网络错误（如超时） | 当 HTTP 状态码为 `4xx/5xx` 或请求未到达服务器（如网络断开、超时）时触发 |

---

## **2. 回调函数的参数及其属性**
两个回调函数的参数是 Axios 封装的标准对象，但其内容略有差异：

### **（1）成功回调的参数：`response`**
成功回调的参数包含以下属性：

| 属性名       | 类型     | 描述                                                      |
| ------------ | -------- | --------------------------------------------------------- |
| `data`       | `any`    | 服务器返回的响应数据（如 JSON、文本等）                   |
| `status`     | `number` | HTTP 状态码（如 200）                                     |
| `statusText` | `string` | HTTP 状态描述（如 "OK"）                                  |
| `headers`    | `object` | 响应头信息（如 `{ 'content-type': 'application/json' }`） |
| `config`     | `object` | 触发该请求的原始配置（包含 URL、method 等）               |
| `request`    | `object` | 生成该响应的原始请求对象（如 XMLHttpRequest 实例）        |

### **（2）错误回调的参数：`error`**
错误回调的参数包含以下属性：

| 属性名         | 类型      | 描述                                                         |
| -------------- | --------- | ------------------------------------------------------------ |
| `response`     | `object`  | 服务器返回的错误响应（结构与成功回调的 `response` 相同），仅适用于 HTTP 错误 |
| `request`      | `object`  | 触发错误的原始请求对象，仅适用于请求已发送但未收到响应的情况（如网络错误） |
| `message`      | `string`  | 错误描述信息（如 "Network Error"）                           |
| `config`       | `object`  | 原始请求的配置信息                                           |
| `isAxiosError` | `boolean` | 标识是否为 Axios 封装的错误（始终为 `true`）                 |

---

## **3. 实际应用示例**
### **（1）处理成功响应**
以下示例展示了如何提取服务器返回的业务数据：
```javascript
axios.interceptors.response.use(
  response => {
    // 假设接口返回格式为 { code: 200, data: {...} }
    if (response.data.code === 200) {
      return response.data.data; // 提取实际业务数据
    }
    return Promise.reject(response.data); // 业务逻辑错误处理
  }
);
```

### **（2）处理错误响应**
以下示例展示了如何统一处理错误并给出提示：
```javascript
axios.interceptors.response.use(
  null, // 跳过成功处理
  error => {
    if (error.response) {
      // 服务器返回的 HTTP 错误
      console.error(`服务器错误：状态码 ${error.response.status}`);
    } else if (error.request) {
      // 请求未到达服务器（如网络问题）
      console.error('网络异常，请检查您的网络连接');
    } else {
      // 其他错误（如配置错误）
      console.error(`请求错误：${error.message}`);
    }
    return Promise.reject(error); // 将错误传递给调用者
  }
);
```

---

## **4. 注意事项**
1. **参数命名规范**  
   - 成功回调的参数通常命名为 `response`，错误回调的参数命名为 `error`，但可以根据需求自定义。
   
2. **属性的存在条件**  
   - `error.response`：仅当服务器返回 HTTP 错误时存在。
   - `error.request`：仅当请求已发送但未收到响应时存在（如超时、网络断开）。
   
3. **拦截器的执行顺序**  
   - 多个响应拦截器按照添加顺序依次执行（先进先出）。如果前一个拦截器未正确处理错误，后续拦截器可能无法正常工作。

4. **错误的传递**  
   - 在错误回调中，使用 `Promise.reject(error)` 将错误传递给后续调用链（如 `.catch()`）。

---

## **总结**
通过 Axios 的响应拦截器，可以对成功和失败的响应进行统一处理，比如提取数据、格式化错误提示、记录日志等。合理使用这两个回调函数，可以简化代码逻辑并提高代码的可维护性。更多细节请参考 [Axios 官方文档](https://www.axios-http.cn/docs/interceptors)。
