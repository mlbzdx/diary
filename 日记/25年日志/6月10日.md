# 文章模块

第一步 创建文章类型模型，同步生成数据表

首先创建文章类型的模型表：

```js
const { DataTypes } = require("sequelize");
const sequelize = require("../dbConnect");

// 定义数据模型
module.exports = sequelize.define("blogType", {
    // 这张表拥有哪些字段
    name : {
        type : DataTypes.STRING,
        allowNull : false
    },
    articleCount : {
        type : DataTypes.INTEGER,
        allowNull : false
    },
    order : {
        type : DataTypes.INTEGER,
        allowNull : false
    },
},{
    freezeTableName : true,
    createdAt : false,
    updatedAt : false
});

```

在 `db.js` 中导入即可进行模型同步

```js
const blogTypeModel = require("./model/bannerModel");
```

第二步 梳理文章类型模块逻辑，编写路由层和逻辑层以及数据层的粗略框架

首先创建文件

- 在 `/routes`目录下 创建 `blogTypeRouter.js`文件
- 在 `/service`目录下 创建 `blogTypeService.js`文件
- 在 `/dao/crud`目录下 创建 `blogTypeDao.js`文件

相关路由的功能及对应的服务层方法，数据从方法命名参考

| 路径                 | 方法   | 说明             | 对应的服务层方法         | 对应的数据层方法     |
| -------------------- | ------ | ---------------- | ------------------------ | -------------------- |
| `/api/blogtype`      | POST   | 添加文章分类     | `addBlogTypeService`     | `addBlogTypeDao`     |
| `/api/blogtype`      | GET    | 获取所有文章分类 | `findAllBlogTypeService` | `findAllBlogTypeDao` |
| `/api/blogtype/{id}` | DELETE | 删除文章分类     | `deleteBlogTypeService`  | `.deleteBlogTypeDao` |
| `/api/blogtype/{id}` | PUT    | 修改文章分类     | `updateBlogTypeService`  | `updateBlogTypeDao`  |
| `/api/blogtype/{id}` | GET    | 获取一个分类     | `findOneBlogTypeService` | `findOneBlogTypeDao` |

第三步 实现添加文章分类，梳理完单个例子的逻辑

- 需要使用到`validate.js`验证库，定义验证规则来保证添加到数据库的数据符合规范

```bash
$ npm i validate.js
```

添加文章的路由层：

```js
router.post("/", async (req, res, next) => {
  res.send(await addBlogTypeService(req.body));
});
```

添加文章分类服务层：

```js
module.exports.addBlogTypeService = async (newBlogTypeInfo) => {
  // 定义验证规则
  const validateRule = {
    name: {
      presence: {
        allowEmpty: false,
        message: "文章分类名不能为空",
      },
      type: "string",
    },
    order: {
      presence: {
        allowEmpty: false,
        message: "文章分类级别不能为空",
      },
      type: "integer",
    },
  };
  if (!validate.validate(newBlogTypeInfo, validateRule)) {
    // 数据验证成功，符合要求
    newBlogTypeInfo.articleCount = 0; // 因为是新增的文章分类，所以一开始文章数量为 0
    return formatResponse(0, "", await addBlogTypeDao(newBlogTypeInfo));
  } else {
    throw new ValidateError("数据验证失败");
  }
};
```

添加文章的数据层

```js
module.exports.addBlogTypeDao = async (newBlogTypeInfo) => {
  const { dataValues } = await blogTypeModel.create(newBlogTypeInfo);
  return dataValues;
};
```

第四步 完成实现其他逻辑

完整路由层：

```js
const express = require("express");
const router = express.Router();
const {
  addBlogTypeService,
  findAllBlogTypeService,
  findOneBlogTypeService,
  updateBlogTypeService,
  deleteBlogTypeService,
} = require("../service/blogTypeService");
// 添加文章分类
router.post("/", async (req, res, next) => {
  res.send(await addBlogTypeService(req.body));
});

// 获取所有文章分类
router.get("/", async (req, res, next) => {
  res.send(await findAllBlogTypeService());
});

// 获取单个文章分类
router.get("/:id", async (req, res, next) => {
  res.send(await findOneBlogTypeService(req.params.id));
});

// 修改单个文章分类
router.put("/:id", async (req, res, next) => {
  res.send(await updateBlogTypeService(req.params.id, req.body));
});

// 删除单个文章分类
router.delete("/:id", async (req, res, next) => {
  res.send(await deleteBlogTypeService(req.params.id));
});

module.exports = router;
```

完整服务层

```js
const validate = require("validate.js");
const {
  addBlogTypeDao,
  findAllBlogTypeDao,
  findOneBlogTypeDao,
  updateBlogTypeDao,
  deleteBlogTypeDao,
} = require("../dao/crud/blogTypeDao");
const { formatResponse, handleArryData } = require("../utils/tool");
const { ValidateError } = require("../utils/errors");

// 添加文章分类
module.exports.addBlogTypeService = async (newBlogTypeInfo) => {
  // 定义验证规则
  const validateRule = {
    name: {
      presence: {
        allowEmpty: false,
        message: "文章分类名不能为空",
      },
      type: "string",
    },
    order: {
      presence: {
        allowEmpty: false,
        message: "文章分类级别不能为空",
      },
      type: "string",
    },
  };
  if (!validate.validate(newBlogTypeInfo, validateRule)) {
    // 数据验证成功，符合要求
    newBlogTypeInfo.articleCount = 0; // 因为是新增的文章分类，所以一开始文章数量为 0
    return formatResponse(0, "", await addBlogTypeDao(newBlogTypeInfo));
  } else {
    throw new ValidateError("数据验证失败");
  }
};

// 获取所有文章分类
module.exports.findAllBlogTypeService = async () => {
  const data = handleArryData(await findAllBlogTypeDao());
  return formatResponse(
    0,
    "",
    data.sort((a, b) => a.order - b.order)
  );
};

// 获取单个文章分类
module.exports.findOneBlogTypeService = async (id) => {
  return formatResponse(0, "", await findOneBlogTypeDao(id));
};

// 修改文章分类
module.exports.updateBlogTypeService = async (id, updatedBlogTypeInfo) => {
  return formatResponse(
    0,
    "",
    await updateBlogTypeDao(id, updatedBlogTypeInfo)
  );
};

// 删除文章分类
module.exports.deleteBlogTypeService = async (id) => {
  await deleteBlogTypeDao(id);
  return formatResponse(0, "", true);
};
```

完整数据层

```js
const blogTypeModel = require("../model/blogTypeModel");

// 添加文章分类
module.exports.addBlogTypeDao = async (newBlogTypeInfo) => {
  const { dataValues } = await blogTypeModel.create(newBlogTypeInfo);
  return dataValues;
};

// 获取所有文章分类
module.exports.findAllBlogTypeDao = async () => {
  return await blogTypeModel.findAll();
};

// 获取单个文章分类
module.exports.findOneBlogTypeDao = async (id) => {
  const { dataValues } = await blogTypeModel.findByPk(id);
  return dataValues;
};

// 修改文章分类
module.exports.updateBlogTypeDao = async (id, updatedBlogTypeInfo) => {
  await blogTypeModel.update(updatedBlogTypeInfo, {
    where: {
      id,
    },
  });
  const { dataValues } = await blogTypeModel.findByPk(id);
  return dataValues;
};

// 删除文章分类
module.exports.deleteBlogTypeDao = async (id) => {
  return blogTypeModel.destroy({
    where: { id },
    force: true, // 强制删除
  });
};
```

# validate

`validate.validate(newBlogTypeInfo, blogTypeRule)` 是 `validate.js` 库中用于执行数据验证的核心方法。以下是详细解析：

---

### 方法签名解析

```javascript
validate(attributes, constraints, [options])
```

- **`attributes`**: `newBlogTypeInfo`  
  需要验证的**数据对象**，通常是用户输入或提交的表单数据。

  ```javascript
  // 示例：
  const newBlogTypeInfo = {
    name: "技术文章",
    order: "2"
  };
  ```

- **`constraints`**: `blogTypeRule`  
  验证规则的**配置对象**，描述了每个字段的验证逻辑。

  ```javascript
  // 示例：
  const blogTypeRule = {
    name: { /*...*/ },
    order: { /*...*/ }
  };
  ```

- **`[options]`** (可选)：  
  附加的配置项，用于修改验证行为（如自定义错误格式）。

---

### 执行流程解析

1. **读取规则字段**  
   遍历 `blogTypeRule` 中的每个字段（如 `name`, `order`），并检查其是否出现在 `newBlogTypeInfo` 中。

2. **逐字段验证**  
   针对每个字段执行以下验证步骤：
   - 检查 `presence` 规则 → 字段是否存在且非空
   - 检查 `type` 规则 → 值是否符合指定类型
   - 检查其他规则（如 `length`, `format` 等）

3. **返回验证结果**  
   - **验证通过** → 返回 `undefined`
   - **验证失败** → 返回包含错误信息的对象

---

### 返回值详解

#### 验证成功

```javascript
// 当数据符合所有规则时
const result = validate({ name: "技术", order: "1" }, blogTypeRule);
console.log(result); // undefined (无错误)
```

#### 验证失败

```javascript
// 当数据不符合规则时
const result = validate({ name: "", order: 123 }, blogTypeRule);
console.log(result);
/* 返回结果：
{
  name: ["Name can't be blank"],
  order: ["Order must be of type string"]
}
*/
```

**错误对象结构**：

```javascript
{
  字段名1: [ "错误描述1", "错误描述2" ],
  字段名2: [ "错误描述3" ]
}
```

---

### 常见使用场景

```javascript
// 在表单提交时验证数据
function submitBlogType(data) {
  const errors = validate(data, blogTypeRule);
  
  if (errors) {
    // 显示错误信息给用户
    showFormErrors(errors);
    return false;
  }
  
  // 验证通过，继续提交
  api.saveBlogType(data);
}
```

---

### 特性说明

1. **短路验证**  
   默认情况下，当字段违反多个规则时，只返回**第一个错误**（可通过配置返回所有错误）。

2. **空值处理**  
   `validate.js` 对空值的处理逻辑：

   ```javascript
   // 以下情况会触发 presence 错误：
   validate({}, blogTypeRule);        // → 缺少字段
   validate({ name: null }, blogTypeRule); // → 空值不符合规则
   ```

3. **嵌套对象支持**  
   支持验证嵌套结构的数据：

   ```javascript
   validate({
     category: {
       name: "技术",
       order: "1"
     }
   }, {
     category: {
       object: blogTypeRule // 针对嵌套对象使用规则
     }
   });
   ```

---

### 配置选项示例

```javascript
// 返回所有错误（不止第一个）
const errors = validate(data, rules, { fullMessages: false, format: "flat" });

// 自定义空值检测
validate.isEmpty = value => value === "" || value === null;

// 自定义错误格式
const errors = validate(data, rules, {
  format: "detailed" // 返回 { attribute, error, value } 对象数组
});
```

---

> 💡 **最佳实践**：在执行重要业务逻辑（如 API 请求、数据库存储）之前，使用 `validate.js` 确保数据有效性。在用户界面层，可以结合实时校验功能，为用户提供更友好的交互体验。

# 验证规则

在 `validate.js` 中，通过声明式 JSON 对象配置字段规则。以下是核心配置指南，涵盖常用验证器及其使用场景：

---

### 一、**规则配置基础结构**

```javascript
const rules = {
  字段名: {
    验证器1: 配置选项,
    验证器2: 配置选项,
    // ...
  }
};
```

---

### 二、**常用内置验证器配置**

#### 1. **存在性校验** (`presence`)

```javascript
username: {
  presence: {
    allowEmpty: false, // 禁止空字符串（默认 true）
    message: "^用户名不能为空" // 自定义错误提示
  }
}
```

#### 2. **数据类型校验** (`type`)

```javascript
age: {
  type: "integer", // 整数
  numericality: {   // 数值范围
    greaterThan: 0,
    lessThanOrEqualTo: 120
  }
}
```

支持类型：`string | boolean | integer | number | array | object | date`

#### 3. **长度校验** (`length`)

```javascript
password: {
  length: {
    minimum: 8,     // 最小长度
    maximum: 20,    // 最大长度
    tooShort: "至少需要 %{count} 位字符",
    tooLong: "不能超过 %{count} 位字符"
  }
}
```

#### 4. **格式校验** (`format`)

```javascript
email: {
  format: {
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, // 邮箱正则
    message: "无效的邮箱格式"
  }
}
```

#### 5. **枚举校验** (`inclusion`)

```javascript
role: {
  inclusion: {
    within: ["admin", "editor", "user"], // 允许值
    message: "无效的用户角色"
  }
}
```

#### 6. **相等性校验** (`equality`)

```javascript
passwordConfirm: {
  equality: {
    attribute: "password", // 需匹配的字段名
    message: "两次密码不一致"
  }
}
```

#### 7. **日期校验** (`datetime`)

```javascript
birthday: {
  datetime: {
    dateOnly: true, // 仅日期（不含时间）
    earliest: new Date(1900, 0, 1), // 最早日期
    latest: new Date() // 最晚日期（今天）
  }
}
```

---

### 三、**高级配置技巧**

#### 1. **条件校验**

```javascript
paymentMethod: {
  presence: true,
  inclusion: { within: ["credit", "paypal"] }
},
creditCard: {
  presence: {
    message: "需要信用卡信息",
    if: (value, attributes) => attributes.paymentMethod === "credit"
  },
  format: { pattern: /^\d{16}$/ }
}
```

#### 2. **嵌套对象校验**

```javascript
user: {
  type: "object",
  presence: true,
  object: {
    name: { presence: true },
    address: {
      type: "object",
      street: { presence: true },
      city: { presence: true }
    }
  }
}
```

#### 3. **数组校验**

```javascript
tags: {
  type: "array",
  length: { minimum: 1, maximum: 5 },
  array: {
    inclusion: { within: ["js", "css", "html"] }
  }
}
```

---

### 四、**自定义验证器示例**

```javascript
// 注册自定义验证器
validate.validators.phone = function(value) {
  if (!value) return null; // 允许空值
  return /^1[3-9]\d{9}$/.test(value) ? null : "无效的手机号";
};

// 使用自定义验证器
const rules = {
  mobile: {
    phone: true // 启用自定义验证
  }
};
```

---

### 五、**完整配置示例**

```javascript
const userRules = {
  username: {
    presence: { allowEmpty: false },
    length: { minimum: 4, maximum: 16 },
    format: { pattern: /^[a-z0-9_]+$/i }
  },
  email: {
    presence: true,
    email: true
  },
  age: {
    numericality: {
      onlyInteger: true,
      greaterThan: 13
    }
  },
  interests: {
    type: "array",
    length: { maximum: 3 }
  },
  profile: {
    type: "object",
    object: {
      bio: {
        type: "string",
        length: { maximum: 200 }
      }
    }
  }
};

// 执行验证
const errors = validate(userData, userRules);
```

---

### 六、**最佳实践建议**

1. **分层验证**：对复杂对象拆分多级规则

2. **复用规则**：共享基础规则（如 `baseUserRules`）

3. **动态规则**：根据业务状态生成规则

   ```javascript
   const getRules = (isAdmin) => ({
     accessLevel: {
       inclusion: { within: isAdmin ? [1,2,3] : [1] }
     }
   });
   ```

4. **错误消息定制**：

   ```javascript
   validate.validators.presence.message = "不能为空";
   ```

> 📘 官方文档参考：[validate.js Constraints](https://validatejs.org/#validators)  
> 建议结合业务需求选择验证器组合，优先使用内置验证器保证性能。

是的，JavaScript 数组内置了 `sort()` 方法，这是数组中最常用的功能之一。使用时需要注意其特性和行为：

---

### 基础用法

```javascript
const fruits = ['banana', 'apple', 'orange', 'grape'];
fruits.sort();
console.log(fruits); 
// 输出: ['apple', 'banana', 'grape', 'orange'] (按字母顺序排序)
```

---

### 重要特性

#### 1. **原地排序**

`sort()` 方法会直接修改原数组，而不是生成新数组。

```javascript
const numbers = [3, 1, 4, 1, 5, 9];
const sorted = numbers.sort();
console.log(numbers);   // [1, 1, 3, 4, 5, 9] - 原数组被修改
console.log(sorted);    // [1, 1, 3, 4, 5, 9] - 返回的是原数组的引用
```

#### 2. **默认按字符串排序**

`sort()` 默认将数组中的元素转换为字符串，并按字典序进行排序。

```javascript
const nums = [10, 2, 1, 5];
nums.sort();
console.log(nums); // [1, 10, 2, 5] - 不是数值顺序！
```

---

### 正确排序数字

为了正确排序数字，需要提供一个**比较函数**：

```javascript
const nums = [10, 2, 1, 5];

// 升序排序
nums.sort((a, b) => a - b);
console.log(nums); // [1, 2, 5, 10]

// 降序排序
nums.sort((a, b) => b - a);
console.log(nums); // [10, 5, 2, 1]
```

---

### 对象数组排序

对于对象数组，可以通过比较函数指定排序字段：

```javascript
const users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

// 按年龄升序
users.sort((a, b) => a.age - b.age);
console.log(users);
/* 输出:
[
  {name: 'Bob', age: 25},
  {name: 'Alice', age: 30},
  {name: 'Charlie', age: 35}
]
*/
```

---

### 复杂排序示例

可以通过嵌套比较逻辑实现多条件排序：

```javascript
const items = [
  { name: 'Apple', type: 'fruit', price: 1.2 },
  { name: 'Carrot', type: 'vegetable', price: 0.8 },
  { name: 'Banana', type: 'fruit', price: 1.0 }
];

// 先按类型排序，再按价格排序
items.sort((a, b) => {
  if (a.type !== b.type) {
    return a.type.localeCompare(b.type); // 按类型字母顺序
  }
  return a.price - b.price; // 同类型时按价格升序
});
```

---

### 注意事项

#### 1. **稳定性**

现代浏览器和 Node.js 中的 `sort()` 方法是**稳定排序**，即对于值相等的元素，排序后会保持其原始顺序。

#### 2. **性能**

`sort()` 方法在 V8 引擎中使用的是 **TimSort** 算法，这是一种混合了归并排序和插入排序的高效算法，适用于大多数场景。

#### 3. **特殊值处理**

`sort()` 会将 `null` 和 `undefined` 等特殊值排在数组末尾：

```javascript
const arr = [null, undefined, 10, 1];
arr.sort();
console.log(arr); 
// [1, 10, null, undefined]
```

---

### 最佳实践

#### 1. **避免修改原数组**

如果需要保留原数组不变，可以使用扩展运算符创建一个新数组：

```javascript
const nums = [3, 1, 4];
const sorted = [...nums].sort((a, b) => a - b);
console.log(nums);    // [3, 1, 4] - 原数组未变
console.log(sorted);  // [1, 3, 4] - 排序后的新数组
```

#### 2. **具名比较函数**

为了提高代码可读性，可以将比较逻辑提取为具名函数：

```javascript
const compareByAge = (a, b) => a.age - b.age;
users.sort(compareByAge);
```

---

### 总结

`sort()` 是一个功能强大的数组方法，但需要理解其默认行为（按字符串排序）和特性（原地排序）。在排序数字和对象数组时，务必提供比较函数以确保正确性。

