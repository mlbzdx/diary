# 需求层面

在 `models`目录下定义各个模型，包括：

- User 用户模型 
- Books 书籍模型
- Classes 班级模型
- Students 学生模型

```text
//根目录 project
.
├── index.js
├── models
│   ├── Admin.js
│   ├── Book.js
│   ├── Class.js
│   ├── db.js
│   ├── Student.js
│   └── sync.js
├── package.json
├── package-lock.json
├── routes
└── services
    └── adminService.js
```

## 表结构

下面列出预期的表结构，围绕该表结构定义模型：

### Users

| id   | loginId | loginPwd | name | avatar | role | status |
| ---- | ------- | -------- | ---- | ------ | ---- | ------ |

### Classes

| id   | name | grade | studentCount | headTeacher | description |
| ---- | ---- | ----- | ------------ | ----------- | ----------- |

### Students

| id   | studentNo | name | gender | birthDate | enrollmentDate | phone | address | classId |
| ---- | --------- | ---- | ------ | --------- | -------------- | ----- | ------- | ------- |

### Books

| id   | bookCode | title | type | author | description | coverImage | publishser | publishDate |
| ---- | -------- | ----- | ---- | ------ | ----------- | ---------- | ---------- | ----------- |

# 知识层面

## 定义模型的两种方法

在 Sequelize 中，定义模型有两种等效的方法，分别是通过 **`sequelize.define()`** 和 **扩展 `Model` 类并调用 `init()`**。以下是两种方法的详细总结和对比：

---

### 1. **使用 `sequelize.define()`（函数式风格）**
**语法**：

```javascript
const Model = sequelize.define(modelName, attributes, options);
```
**参数说明**：

- **`modelName`**：模型名称（如 `'User'`），默认会转换为复数表名（如 `Users`）。
- **`attributes`**：定义表字段的对象，每个属性指定字段类型和约束（如 `allowNull`、`defaultValue`）。
- **`options`**：可选配置，如 `tableName`（自定义表名）、`timestamps`（禁用时间戳）等。

**示例**：

```javascript
const User = sequelize.define('User', {
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: DataTypes.STRING // 简写形式
}, {
  tableName: 'my_users', // 自定义表名
  timestamps: false      // 禁用 createdAt/updatedAt
});
```

**特点**：
- 语法简洁，适合快速原型开发。
- 内部会自动调用 `Model.init()`，与继承 `Model` 类等效。

---

### 2. **扩展 `Model` 类并调用 `init()`（面向对象风格）**
**语法**：

```javascript
class ModelName extends Model {}
ModelName.init(attributes, options);
```
**参数说明**：
- **`attributes`**：与 `define()` 相同，定义字段及其属性。
- **`options`**：必须包含 `sequelize` 实例和 `modelName`，其他配置与 `define()` 一致。

**示例**：
```javascript
class User extends Model {}
User.init({
  firstName: DataTypes.STRING,
  lastName: DataTypes.STRING
}, {
  sequelize,          // 必须传入 Sequelize 实例
  modelName: 'User',  // 指定模型名
  freezeTableName: true // 禁止自动复数化表名
});
```

**特点**：
- 更适合 TypeScript 项目，可通过 `declare` 声明字段类型。
- 支持扩展自定义方法（如实例方法或类方法）。



## 字段类型配置：

以下是 Sequelize 中定义模型时支持的主要数据类型，结合官方文档及社区实践整理而成：

---

### 1. **字符串类型**
- **`STRING` / `STRING(length)`**  
  映射到数据库的 `VARCHAR` 类型，默认长度为 255（如 `VARCHAR(255)`），可自定义长度（例如 `STRING(1234)` 对应 `VARCHAR(1234)`）。
  
- **`TEXT` / `TEXT('tiny')`**  
  用于存储长文本，`TEXT` 默认无长度限制，`TEXT('tiny')` 对应 `TINYTEXT`（最大 255 字符）。
  
- **`CITEXT`**  
  大小写不敏感的文本类型，仅支持 PostgreSQL 和 SQLite。
  
- **`BINARY`**  
  二进制字符串类型，例如 `STRING.BINARY` 映射为 `VARCHAR BINARY`。

---

### 2. **数字类型**
- **`INTEGER`**  
  标准整数类型，范围为 -2147483648 ~ 2147483647。
  
- **`BIGINT` / `BIGINT(length)`**  
  大整数类型，范围为 ±9.22×10¹⁸，可指定显示长度（例如 `BIGINT(11)`）。
  
- **`FLOAT` / `FLOAT(length, decimals)`**  
  单精度浮点数，可指定总位数和小数位（例如 `FLOAT(11, 10)`）。
  
- **`DOUBLE` / `DOUBLE(length, decimals)`**  
  双精度浮点数，与 `FLOAT` 类似，但精度更高。
  
- **`DECIMAL` / `DECIMAL(precision, scale)`**  
  定点数类型，例如 `DECIMAL(10, 2)` 表示总位数为 10、小数位为 2。
  
- **`REAL`**  
  浮点数类型，仅支持 PostgreSQL。

---

### 3. **日期与时间类型**
- **`DATE`**  
  映射到数据库的 `DATETIME`（MySQL/SQLite）或带时区的 `TIMESTAMP`（PostgreSQL）。
  
- **`DATEONLY`**  
  仅存储日期部分（例如 `'2025-05-09'`），不包含时间信息。
  
- **`DATE(6)`**  
  支持微秒精度的 `DATETIME` 类型（适用于 MySQL 5.6.4+）。

---

### 4. **布尔与枚举类型**
- **`BOOLEAN`**  
  映射为 `TINYINT(1)`，用于存储布尔值 `true`/`false`。
  
- **`ENUM(values)`**  
  枚举类型，例如 `ENUM('active', 'inactive')`，限定字段值范围。

---

### 5. **二进制与 JSON 类型**
- **`BLOB` / `BLOB('tiny')`**  
  用于存储二进制数据，`BLOB('tiny')` 映射为 `TINYBLOB`。
  
- **`JSON`**  
  标准 JSON 数据类型，支持 PostgreSQL、SQLite 和 MySQL。
  
- **`JSONB`**  
  二进制格式的 JSON 类型，仅支持 PostgreSQL。

---

### 6. **特殊类型**
- **`UUID`**  
  通用唯一标识符类型，PostgreSQL 和 SQLite 原生支持，MySQL 映射为 `CHAR(36)`。可通过 `defaultValue: DataTypes.UUIDV4` 自动生成 UUID 值。
  
- **`GEOMETRY`**  
  空间数据类型（如点、线），支持 PostgreSQL（需安装 PostGIS 扩展）和 MySQL。
  
- **`ARRAY(type)`**  
  数组类型，仅支持 PostgreSQL（例如 `ARRAY(STRING)` 或 `ARRAY(ENUM)`）。
  
- **`RANGE(type)`**  
  范围类型（例如整数范围、日期范围），仅支持 PostgreSQL。

---

### 7. **数据库特定类型**
- **`TSVECTOR`**  
  用于 PostgreSQL 的全文搜索功能。
  
- **`CIDR`、`INET`、`MACADDR`**  
  PostgreSQL 的网络和硬件地址类型。



## 字段约束配置

以下是 Sequelize 在定义模型时可用的字段约束条件，涵盖数据类型、验证规则和数据库级约束：

---

### 1. **基础数据类型约束**
- **`type`**：指定字段数据类型，支持以下核心类型：
  - **字符串类型**：`STRING`（默认长度为 255）、`STRING(1234)`（自定义长度）、`TEXT`、`CITEXT`（大小写不敏感）
  - **数字类型**：`INTEGER`、`BIGINT`、`FLOAT`、`DOUBLE`、`DECIMAL(precision, scale)`（定点数）
  - **日期类型**：`DATE`、`DATEONLY`（仅日期部分）、`DATE(6)`（支持微秒精度）
  - **其他类型**：`BOOLEAN`、`JSON`、`JSONB`（二进制 JSON）、`UUID`、`ENUM('val1', 'val2')`（枚举类型）

---

### 2. **空值与非空约束**
- **`allowNull`**：控制字段是否允许 `null`，默认值为 `true`。设置为 `false` 时：
  - Sequelize 会验证字段是否为空，若为空会抛出 `ValidationError`
  - 同步到数据库时会自动添加 `NOT NULL` 约束
  ```javascript
  username: { type: DataTypes.STRING, allowNull: false }  // 强制字段值非空
  ```

---

### 3. **唯一性约束**
- **`unique`**：定义字段的唯一性约束，支持以下两种形式：
  - **单字段唯一**：`unique: true`
  - **复合唯一键**：多个字段共享相同的 `unique` 标识（如 `unique: 'compositeIndex'`）
  ```javascript
  email: { type: DataTypes.STRING, unique: true }  // 邮箱字段唯一
  ```

---

### 4. **主键与自增**
- **`primaryKey`**：将字段定义为主键
- **`autoIncrement`**：定义自增字段，通常与主键搭配使用
  ```javascript
  id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true }
  ```

---

### 5. **默认值与动态赋值**
- **`defaultValue`**：设置字段的默认值，支持静态值或动态生成：
  - **静态值**：`defaultValue: '未命名'`
  - **动态生成**：`defaultValue: Sequelize.NOW`（当前时间）
  ```javascript
  createdAt: { type: DataTypes.DATE, defaultValue: Sequelize.NOW }
  ```

---

### 6. **字段映射与注释**
- **`field`**：自定义数据库列名，例如 `field: 'user_name'` 将字段映射到 `user_name` 列
- **`comment`**：为字段添加注释（仅支持 MySQL、PostgreSQL 和 MSSQL）
  ```javascript
  password: { type: DataTypes.STRING, field: 'pwd_hash', comment: '加密后的密码' }
  ```

---

### 7. **外键关联约束**
- **`references`**：定义外键关联关系
  ```javascript
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'User',  // 关联的目标模型
      key: 'id'       // 目标模型的字段
    },
    onDelete: 'CASCADE',  // 级联删除
    onUpdate: 'RESTRICT'  // 禁止更新
  }
  ```

---

### 8. **验证规则（Sequelize 层校验）**
通过 `validate` 定义字段的校验规则，校验失败时会阻止数据库操作：
- **内置验证器**：例如 `isEmail`（验证邮箱格式）、`isURL`（验证 URL）、`len: [3, 20]`（限制字符串长度）
- **自定义验证器**：通过自定义函数实现复杂校验逻辑
  ```javascript
  age: {
    type: DataTypes.INTEGER,
    validate: {
      min: { args: [0], msg: '年龄不能为负数' }  // 验证最小值
    }
  }
  ```

---

### 9. **高级约束（数据库级）**
- **`indexes`**：定义索引（支持唯一索引、复合索引等）
- **`deferrable`**：PostgreSQL 特有，控制外键约束的检查时机（例如 `INITIALLY DEFERRED`）

---

### 10. **其他实用约束**
- **`get`/`set`**：定义字段的自定义访问器和设置器
- **`omitNull`**：全局配置项，忽略空值字段
- **`paranoid`**：启用逻辑删除功能（会添加 `deletedAt` 字段）

如需了解完整约束选项，请参考 [Sequelize 官方文档](https://sequelize.org/docs/v6/core-concepts/model-basics/)。

## 字段验证配置：

在 Sequelize 中，可以通过 `validate` 属性为模型字段定义验证规则，这些规则会在数据创建（`create`）、更新（`update`）或保存（`save`）时自动触发。以下是详细说明及示例：

---

### 1. **字段级验证规则**
在字段定义中使用 `validate` 对象添加验证规则，支持内置验证器或自定义验证器：
```javascript
const User = sequelize.define('User', {
  email: {
    type: DataTypes.STRING,
    validate: {
      isEmail: true,  // 内置验证器：检查邮箱格式
      notEmpty: { msg: '邮箱不能为空' }  // 自定义错误消息
    }
  },
  password: {
    type: DataTypes.STRING,
    validate: {
      len: [8, 20],  // 密码长度限制
      isStrongPassword(value) {  // 自定义验证器
        if (!/[A-Z]/.test(value) || !/[0-9]/.test(value)) {
          throw new Error('密码必须包含至少一个大写字母和数字');
        }
      }
    }
  }
});
```
**说明**：
- **内置验证器**：如 `isEmail`、`len`、`isInt` 等，直接使用即可。
- **自定义验证器**：通过函数实现复杂逻辑，抛出 `Error` 表示验证失败。

---

### 2. **常用内置验证器**
Sequelize 提供了丰富的内置验证器，基于 `validator.js`，以下是常见验证器及其功能：
| 验证器         | 功能                       | 示例                             |
| -------------- | -------------------------- | -------------------------------- |
| `isEmail`      | 验证邮箱格式               | `isEmail: true`                  |
| `isURL`        | 验证 URL 格式              | `isURL: { protocols: ['http'] }` |
| `isIP`         | 验证 IP 地址               | `isIP: true`                     |
| `len`          | 验证字符串长度范围         | `len: [6, 20]`                   |
| `isIn`         | 验证值是否包含在指定数组中 | `isIn: [['admin', 'user']]`      |
| `notEmpty`     | 禁止空字符串               | `notEmpty: true`                 |
| `isCreditCard` | 验证信用卡号               | `isCreditCard: true`             |

更多验证器详见 [validator.js 文档](https://github.com/validatorjs/validator.js)。

---

### 3. **自定义错误消息**
为内置验证器设置自定义错误提示：
```javascript
validate: {
  isEmail: {
    msg: '请输入有效的邮箱地址'  // 覆盖默认错误消息
  },
  len: {
    args: [8, 20],
    msg: '密码长度必须在 8 到 20 位之间'
  }
}
```
**注意**：自定义验证器的错误消息通过 `throw new Error('错误消息')` 指定。

---

### 4. **条件验证**
结合 `allowNull` 和自定义验证器实现条件校验：
```javascript
age: {
  type: DataTypes.INTEGER,
  allowNull: true,
  validate: {
    isAdult(value) {  // 自定义验证逻辑
      if (value !== null && value < 18) {
        throw new Error('年龄必须大于或等于 18 岁');
      }
    }
  }
}
```
**逻辑说明**：
- 若 `allowNull: true`，字段值为 `null` 时会跳过内置验证器，但仍会执行自定义验证器。

---

### 5. **模型级验证**
在模型配置中定义跨字段的联合验证规则：
```javascript
const Pub = sequelize.define('Pub', {
  latitude: { type: DataTypes.FLOAT, allowNull: true },
  longitude: { type: DataTypes.FLOAT, allowNull: true }
}, {
  validate: {
    bothCoordsOrNone() {  // 验证经纬度必须同时存在或同时为空
      if ((this.latitude === null) !== (this.longitude === null)) {
        throw new Error('经纬度必须同时存在或同时为空');
      }
    }
  }
});
```
**适用场景**：需要对多个字段进行联合验证时。

---

### 6. **验证触发时机**
验证规则会在以下操作时自动触发：
- **创建**：`create()`  
- **更新**：`update()`  
- **保存**：`save()`  
- **手动调用**：`instance.validate()`  

**跳过验证**：
```javascript
await user.save({ validate: false });  // 跳过验证规则
```

---

### 7. **错误处理**
捕获验证错误并提取详细信息：
```javascript
try {
  await User.create({ email: 'invalid', password: '123' });
} catch (error) {
  if (error.name === 'SequelizeValidationError') {
    console.log('验证失败:', error.errors.map(e => e.message));
    // 输出：['请输入有效的邮箱地址', '密码长度必须在 8 到 20 位之间']
  }
}
```

---

通过以上方法，Sequelize 提供了灵活的验证机制，既支持内置规则，也支持复杂的自定义逻辑，帮助确保数据的完整性和准确性。

## 模型选项配置

在 Sequelize 中定义模型时，可以通过各种选项配置模型的行为，包括数据库表映射、命名规则、时间戳管理、钩子函数等功能。以下是详细说明：

---

### 1. **表名与命名规则**
- **`tableName`**  
  手动指定表名，避免默认的复数化规则：
  ```javascript
  { tableName: 'admin_users' }  // 表名固定为 'admin_users'
  ```
- **`freezeTableName`**  
  禁止自动复数化，直接使用模型名作为表名：
  ```javascript
  { freezeTableName: true }  // 表名保持与模型名一致（如 'Admin'）
  ```
- **`underscored`**  
  将字段名转换为蛇形命名（例如 `createdAt` → `created_at`），适用于遵循数据库命名规范的场景：
  ```javascript
  { underscored: true }
  ```

---

### 2. **时间戳管理**
- **`timestamps`**  
  是否自动添加 `createdAt` 和 `updatedAt` 时间戳字段（默认值为 `true`）：
  ```javascript
  { timestamps: false }  // 禁用自动时间戳
  ```
- **`createdAt` / `updatedAt`**  
  自定义时间戳字段的名称：
  ```javascript
  { createdAt: 'create_time', updatedAt: 'update_time' }
  ```
- **`deletedAt`**  
  启用逻辑删除功能（需配合 `paranoid: true` 使用），逻辑删除时会添加 `deletedAt` 字段：
  ```javascript
  { paranoid: true }  // 启用逻辑删除
  ```

---

### 3. **索引与查询作用域**
- **`indexes`**  
  定义表的索引，支持唯一索引、复合索引和条件索引：
  ```javascript
  {
    indexes: [
      { unique: true, fields: ['loginId'] },  // 唯一索引
      { fields: ['status'], where: { status: 'active' } }  // 条件索引
    ]
  }
  ```
- **`defaultScope` / `scopes`**  
  设置默认查询作用域或命名作用域，便于简化查询：
  ```javascript
  {
    defaultScope: { where: { status: 'active' } },
    scopes: { banned: { where: { status: 'banned' } } }
  }
  ```

---

### 4. **其他常用选项**
- **`schema`**  
  指定数据库模式（适用于 PostgreSQL 等支持 schema 的数据库）：
  ```javascript
  { schema: 'admin_schema' }
  ```
- **`engine`**  
  设置存储引擎（例如 MySQL 的 InnoDB）：
  ```javascript
  { engine: 'InnoDB' }
  ```
- **`comment`**  
  为表添加注释（支持部分数据库，如 MySQL、PostgreSQL）：
  ```javascript
  { comment: '管理员账户表' }
  ```

---

### 5. **钩子函数与验证规则**
- **`hooks`**  
  定义模型生命周期钩子函数，用于在特定操作前后执行逻辑：
  ```javascript
  {
    hooks: {
      beforeCreate: (user) => { 
        user.password = encrypt(user.password);  // 在创建模型前加密密码
      }
    }
  }
  ```
- **`validate`**  
  模型级验证规则，用于跨字段校验逻辑：
  ```javascript
  {
    validate: {
      bothDatesOrNone() {  // 开始和结束日期必须同时存在或同时为空
        if ((this.startDate && !this.endDate) || (!this.startDate && this.endDate)) {
          throw new Error('开始和结束日期需同时存在或同时为空');
        }
      }
    }
  }
  ```

---

### 6. **全局配置**
通过 Sequelize 实例的 `define` 选项统一设置所有模型的默认行为：
```javascript
const sequelize = new Sequelize({
  define: { 
    underscored: true,  // 全局字段命名使用蛇形规则
    paranoid: true      // 全局启用逻辑删除功能
  }
});
```

---

完整选项及更多功能请参考 [Sequelize 官方文档](https://sequelize.org/docs/v6/core-concepts/model-basics/#configuration)。

## 案例练习

需求：需要创建一个管理员(Users)数据表，表的列结构如下：

> Users:
>
> - id
> - account 账号
> - password 密码 
> - name 姓名

需求层面：

一个管理员的表结构需要那些？

每个表结构中的列需要什么类型？需要添加那些约束？如果要验证，需要怎么验证？

理清增删改的业务逻辑？

删除数据的业务逻辑

知识层面：

怎样向表里面添加数据？删除数据？修改数据？

增加数据？

- 模型的create方法，构建一个模型实例
- build方法是什么？同步方法吗？
- 调用增加数据的方法后返回的是一个什么？为什么要将其toJSON
- 了解批量添加数据

运行save方法后将实例加入数据库

删除数据？

- 得到实例：查找实例并删除？findByPK
- destroy方法？where指定删除？

更新实例？

- update方法？返回对象？

怎样理解一对一，一对多，多对多关系关系？

学习使用mock来模拟生成数据添加到数据库？

学习抓取数据来添加到数据库？

